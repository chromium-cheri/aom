{
  "comments": [
    {
      "key": {
        "uuid": "51ac159b_de30155c",
        "filename": "aom_dsp/simd/v64_intrinsics_arm.h",
        "patchSetId": 13
      },
      "lineNbr": 74,
      "author": {
        "id": 5435
      },
      "writtenOn": "2016-08-31T19:25:10Z",
      "side": 1,
      "message": "This seem like it runs afoul of clang:\nhttps://llvm.org/bugs/show_bug.cgi?id\u003d24421\n\nThe gist is that it automatically adds a :32 alignment directive to this store, which causes problems.\n\nI\u0027m working around this in a very slow way:\np[0] \u003d vget_lane_u8(a, 0);\n...\np[3] \u003d vget_lane_u8(a, 3);\nbut then a is uint8x8_t, not uint32_t\n\nIt\u0027s so slow I\u0027ll probably check alignment and cast when possible. I asked for a way to hint to clang not to add the alignment directive, but not a whole lot of people are using intrinsics or doing 4x4 transforms.",
      "revId": "e64dcf486245ccaaee565a00ea4ef1d88e428de4",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "312321ee_a7ac0aa8",
        "filename": "aom_dsp/simd/v64_intrinsics_arm.h",
        "patchSetId": 13
      },
      "lineNbr": 74,
      "author": {
        "id": 5111
      },
      "writtenOn": "2016-08-31T20:00:55Z",
      "side": 1,
      "message": "You saying that clang aligns the address when you do a vget_lane_u8() though the architecture supports unaligned stores?  I checked what gcc is doing with unaligned stores through vget_lane_u8() and the assembly looked good and the memory was correctly written to.\n\nWould something like this work?:\n#if __clang__\n  *((__attribute__((aligned(1))) uint32_t *)p) \u003d a;\n#elif __CC_ARM\n...\n\nI have tested the code with arm-gcc only.  Which compilers should be supported?",
      "parentUuid": "51ac159b_de30155c",
      "revId": "e64dcf486245ccaaee565a00ea4ef1d88e428de4",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "31a401cb_bf645718",
        "filename": "aom_dsp/simd/v64_intrinsics_arm.h",
        "patchSetId": 13
      },
      "lineNbr": 74,
      "author": {
        "id": 5435
      },
      "writtenOn": "2016-08-31T22:09:48Z",
      "side": 1,
      "message": "No, with clang vst1_lane_u32() gets a :32 alignment hint on the address. Same for vld1_lane_u32(). _64 instructions get a :64 hint, etc. Without the hint, unaligned access is fine. With :32, unaligned stores will crash. In the llvm bug I asked for a way to use the instruction without getting the hint. Don\u0027t think that happened though.\n\nvget_lane_u32() should be fine since it moves it to a GP register, not to memory. Nothing to run afoul of there.\n\nChrome uses clang and it generally seems to be growing in popularity. We first noticed this on iOS with Xcode. Eventually I assume gcc, clang (including the Apple version), Visual Studio, icc, etc must be supported. I don\u0027t know when they need to be supported. I don\u0027t think anyone is currently running libaom on ARM at all right now.",
      "parentUuid": "312321ee_a7ac0aa8",
      "revId": "e64dcf486245ccaaee565a00ea4ef1d88e428de4",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "91e76d24_52af9482",
        "filename": "aom_dsp/simd/v64_intrinsics_arm.h",
        "patchSetId": 13
      },
      "lineNbr": 74,
      "author": {
        "id": 5435
      },
      "writtenOn": "2016-08-31T22:51:52Z",
      "side": 1,
      "message": "Ah sorry forgot about the __attribute__ from the clang bug. I haven\u0027t read it closely in a while.\n\nYou should be able to use vst1_lane_u32((__attribute__((aligned(1))) uint32_t *)p, vreinterpret_u32_s64(a), 0);\n\nBut I\u0027m really not sure how to treat this because the framework is using uint32_t instead of uint8x8_t so I\u0027m not sure the compiler will move it to neon, move it from neon, etc. If you\u0027re doing simd on the uint32_t, when/how does it get moved, whether it\u0027s better to use the vst1() instructions or casting the pointer.\n\nGoing from the other things,\n*((__attribute__((aligned(1))) uint32_t *)p) \u003d a;\nseems fine but presumably won\u0027t generate a neon instruction.",
      "parentUuid": "31a401cb_bf645718",
      "revId": "e64dcf486245ccaaee565a00ea4ef1d88e428de4",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    }
  ]
}