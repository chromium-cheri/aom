{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "cd06fb28_35ce95f9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 11
      },
      "lineNbr": 0,
      "author": {
        "id": 9545
      },
      "writtenOn": "2021-07-21T00:20:06Z",
      "side": 1,
      "message": "Bohan: I suggest some changes. Thanks!",
      "revId": "768e40939ddeea313af10199fc396be4088dee93",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f5dbcd86_ba15cb14",
        "filename": "av1/av1_cx_iface.c",
        "patchSetId": 11
      },
      "lineNbr": 511,
      "author": {
        "id": 9545
      },
      "writtenOn": "2021-07-21T00:20:06Z",
      "side": 1,
      "message": "Nit/optional: I suggest we change the return type to aom_codec_err_t so that we can return AOM_CODEC_INVALID_PARAM at line 513 and AOM_CODEC_NO_MEM at line 527. Alternatively, we can require that the caller pass a non-null \u0027src\u0027 argument to this function. Then we can remove line 513 and this function will only fail for out-of-memory errors.",
      "range": {
        "startLine": 511,
        "startChar": 7,
        "endLine": 511,
        "endChar": 10
      },
      "revId": "768e40939ddeea313af10199fc396be4088dee93",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bd9fb4c6_53824f88",
        "filename": "av1/av1_cx_iface.c",
        "patchSetId": 11
      },
      "lineNbr": 511,
      "author": {
        "id": 9545
      },
      "writtenOn": "2021-07-21T00:20:06Z",
      "side": 1,
      "message": "Nit: Please add a function comment that summarizes what this function does. No need to write a Doxygen comment.",
      "revId": "768e40939ddeea313af10199fc396be4088dee93",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "bb741eb4_3af43c99",
        "filename": "av1/av1_cx_iface.c",
        "patchSetId": 11
      },
      "lineNbr": 511,
      "author": {
        "id": 7525
      },
      "writtenOn": "2021-07-21T18:03:04Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "f5dbcd86_ba15cb14",
      "range": {
        "startLine": 511,
        "startChar": 7,
        "endLine": 511,
        "endChar": 10
      },
      "revId": "768e40939ddeea313af10199fc396be4088dee93",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f489a4f3_d88700fa",
        "filename": "av1/av1_cx_iface.c",
        "patchSetId": 11
      },
      "lineNbr": 511,
      "author": {
        "id": 7525
      },
      "writtenOn": "2021-07-21T18:03:04Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "bd9fb4c6_53824f88",
      "revId": "768e40939ddeea313af10199fc396be4088dee93",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a04f0e57_c421d91d",
        "filename": "av1/av1_cx_iface.c",
        "patchSetId": 11
      },
      "lineNbr": 517,
      "author": {
        "id": 9545
      },
      "writtenOn": "2021-07-21T00:20:06Z",
      "side": 1,
      "message": "I think we should compare *dst !\u003d default_src instead of strcmp(*dst, default_src) !\u003d 0. The *dst !\u003d default_src check is a stronger check to verify that line 523 was executed.",
      "range": {
        "startLine": 517,
        "startChar": 31,
        "endLine": 517,
        "endChar": 61
      },
      "revId": "768e40939ddeea313af10199fc396be4088dee93",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ff989fcb_746c4b0b",
        "filename": "av1/av1_cx_iface.c",
        "patchSetId": 11
      },
      "lineNbr": 517,
      "author": {
        "id": 7525
      },
      "writtenOn": "2021-07-21T18:03:04Z",
      "side": 1,
      "message": "Yeah that makes more sense. Thanks!",
      "parentUuid": "a04f0e57_c421d91d",
      "range": {
        "startLine": 517,
        "startChar": 31,
        "endLine": 517,
        "endChar": 61
      },
      "revId": "768e40939ddeea313af10199fc396be4088dee93",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f12d43b2_27e858e8",
        "filename": "av1/av1_cx_iface.c",
        "patchSetId": 11
      },
      "lineNbr": 525,
      "author": {
        "id": 9545
      },
      "writtenOn": "2021-07-21T00:20:06Z",
      "side": 1,
      "message": "Declare \u0027len\u0027 as size_t:\n\n    size_t len \u003d strlen(src) + 1;",
      "revId": "768e40939ddeea313af10199fc396be4088dee93",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d89ce7f3_d2e9afcd",
        "filename": "av1/av1_cx_iface.c",
        "patchSetId": 11
      },
      "lineNbr": 525,
      "author": {
        "id": 7525
      },
      "writtenOn": "2021-07-21T18:03:04Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "f12d43b2_27e858e8",
      "revId": "768e40939ddeea313af10199fc396be4088dee93",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e2cbfc7f_d4fa473a",
        "filename": "av1/av1_cx_iface.c",
        "patchSetId": 11
      },
      "lineNbr": 526,
      "author": {
        "id": 9545
      },
      "writtenOn": "2021-07-21T00:20:06Z",
      "side": 1,
      "message": "sizeof(tmp) is incorrect because \u0027tmp\u0027 is a pointer. It should be sizeof(*tmp), sizeof(tmp[0]), or sizeof(char). Since sizeof(char) is 1 (see https://stackoverflow.com/questions/2215445/are-there-machines-where-sizeofchar-1-or-at-least-char-bit-8), I suggesr we omit the sizeof.",
      "revId": "768e40939ddeea313af10199fc396be4088dee93",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "14542096_8f4e9c8b",
        "filename": "av1/av1_cx_iface.c",
        "patchSetId": 11
      },
      "lineNbr": 526,
      "author": {
        "id": 7525
      },
      "writtenOn": "2021-07-21T18:03:04Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "e2cbfc7f_d4fa473a",
      "revId": "768e40939ddeea313af10199fc396be4088dee93",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "731fdd3c_c1001e1e",
        "filename": "av1/av1_cx_iface.c",
        "patchSetId": 11
      },
      "lineNbr": 528,
      "author": {
        "id": 9545
      },
      "writtenOn": "2021-07-21T00:20:06Z",
      "side": 1,
      "message": "Use memcpy() instead:\n\n  memcpy(tmp, src, len);",
      "revId": "768e40939ddeea313af10199fc396be4088dee93",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f564b00a_26332004",
        "filename": "av1/av1_cx_iface.c",
        "patchSetId": 11
      },
      "lineNbr": 528,
      "author": {
        "id": 7525
      },
      "writtenOn": "2021-07-21T18:03:04Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "731fdd3c_c1001e1e",
      "revId": "768e40939ddeea313af10199fc396be4088dee93",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "563cf3df_69ecb9bf",
        "filename": "av1/av1_cx_iface.c",
        "patchSetId": 11
      },
      "lineNbr": 1148,
      "author": {
        "id": 9545
      },
      "writtenOn": "2021-07-21T00:20:06Z",
      "side": 1,
      "message": "This is another scenario where we may need to copy the string. Have you verified that extra_cfg will stay valid during the lifetime of oxcf? If so, then it is safe to just copy the string pointer (i.e., a shallow copy).",
      "revId": "768e40939ddeea313af10199fc396be4088dee93",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1782c92b_7b553bdc",
        "filename": "av1/av1_cx_iface.c",
        "patchSetId": 11
      },
      "lineNbr": 1148,
      "author": {
        "id": 7525
      },
      "writtenOn": "2021-07-21T18:03:04Z",
      "side": 1,
      "message": "It should stay valid as the strings are only freed when encoder_destroy was called, at which time we probably do not care about oxcf anymore.",
      "parentUuid": "563cf3df_69ecb9bf",
      "revId": "768e40939ddeea313af10199fc396be4088dee93",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0be57c4e_c2004bfa",
        "filename": "av1/av1_cx_iface.c",
        "patchSetId": 11
      },
      "lineNbr": 1148,
      "author": {
        "id": 9545
      },
      "writtenOn": "2021-07-22T22:23:47Z",
      "side": 1,
      "message": "Thank you. I verified that extra_cfg and oxcf are members of the same aom_codec_alg_priv_t struct, so they are very likely to have the same lifetime.",
      "parentUuid": "1782c92b_7b553bdc",
      "revId": "768e40939ddeea313af10199fc396be4088dee93",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "172c7950_5f469d5b",
        "filename": "av1/av1_cx_iface.c",
        "patchSetId": 11
      },
      "lineNbr": 2125,
      "author": {
        "id": 9545
      },
      "writtenOn": "2021-07-21T00:20:06Z",
      "side": 1,
      "message": "Note: Please make the same changes to the similar code below.\n\n1. In the error message, change \"space\" to memory.\n2. Change the return value to AOM_CODEC_MEM_ERROR. If we change allocate_and_set_string() to return aom_codec_err_t, then we can just return its return value. However, the error message is only correct for AOM_CODEC_NO_MEM, not for the !str case.",
      "revId": "768e40939ddeea313af10199fc396be4088dee93",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1a598543_0b3d6575",
        "filename": "av1/av1_cx_iface.c",
        "patchSetId": 11
      },
      "lineNbr": 2125,
      "author": {
        "id": 7525
      },
      "writtenOn": "2021-07-21T18:03:04Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "172c7950_5f469d5b",
      "revId": "768e40939ddeea313af10199fc396be4088dee93",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7513ca7e_79c48bb8",
        "filename": "av1/av1_cx_iface.c",
        "patchSetId": 11
      },
      "lineNbr": 2495,
      "author": {
        "id": 9545
      },
      "writtenOn": "2021-07-21T00:20:06Z",
      "side": 1,
      "message": "It seems that we should check default_str \u003d\u003d *ptr instead of strcmp(default_str, *ptr) \u003d\u003d 0.",
      "range": {
        "startLine": 2495,
        "startChar": 29,
        "endLine": 2495,
        "endChar": 59
      },
      "revId": "768e40939ddeea313af10199fc396be4088dee93",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b187a819_a89ae6b0",
        "filename": "av1/av1_cx_iface.c",
        "patchSetId": 11
      },
      "lineNbr": 2495,
      "author": {
        "id": 7525
      },
      "writtenOn": "2021-07-21T18:03:04Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "7513ca7e_79c48bb8",
      "range": {
        "startLine": 2495,
        "startChar": 29,
        "endLine": 2495,
        "endChar": 59
      },
      "revId": "768e40939ddeea313af10199fc396be4088dee93",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d17771f3_4433b41e",
        "filename": "av1/av1_cx_iface.c",
        "patchSetId": 11
      },
      "lineNbr": 2498,
      "author": {
        "id": 9545
      },
      "writtenOn": "2021-07-21T00:20:06Z",
      "side": 1,
      "message": "Nit: Omit the \"else\" after a return statement:\n\n  if (default_str \u0026\u0026 *ptr \u0026\u0026 strcmp(default_str, *ptr) \u003d\u003d 0) {\n    // Default should be a literal. Do not free.\n    return;\n  }\n  aom_free((void *)*ptr);\n  *ptr \u003d default_str;",
      "revId": "768e40939ddeea313af10199fc396be4088dee93",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e7cd87a9_a1ffaf22",
        "filename": "av1/av1_cx_iface.c",
        "patchSetId": 11
      },
      "lineNbr": 2498,
      "author": {
        "id": 7525
      },
      "writtenOn": "2021-07-21T18:03:04Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "d17771f3_4433b41e",
      "revId": "768e40939ddeea313af10199fc396be4088dee93",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "11ab17f1_28398c2a",
        "filename": "av1/av1_cx_iface.c",
        "patchSetId": 11
      },
      "lineNbr": 2500,
      "author": {
        "id": 9545
      },
      "writtenOn": "2021-07-21T00:20:06Z",
      "side": 1,
      "message": "Why do we set *ptr to default_str after freeing the string?\n\nUsually we set a pointer to NULL after freeing it.",
      "revId": "768e40939ddeea313af10199fc396be4088dee93",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "57d951c8_b3f7cfcb",
        "filename": "av1/av1_cx_iface.c",
        "patchSetId": 11
      },
      "lineNbr": 2500,
      "author": {
        "id": 7525
      },
      "writtenOn": "2021-07-21T23:12:40Z",
      "side": 1,
      "message": "I think both would work. Initially I was concerned that after encoder_destroy() they may still get used later for next encoder_init(). But it seems that in encoder_init() they will get assigned to default values. Do you think it is better to use NULL here?",
      "parentUuid": "11ab17f1_28398c2a",
      "revId": "768e40939ddeea313af10199fc396be4088dee93",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d5c96d70_e5ef6205",
        "filename": "av1/av1_cx_iface.c",
        "patchSetId": 11
      },
      "lineNbr": 2500,
      "author": {
        "id": 9545
      },
      "writtenOn": "2021-07-22T22:23:47Z",
      "side": 1,
      "message": "Yes, setting a pointer to NULL after freeing it is a common pattern.\n\nNote: encoder_destroy() frees its \u0027ctx\u0027 parameter, so the memory will not be used by the next encoder_init(). The \u0027ctx\u0027 parameters of encoder_init() and encoder_destroy() have different types. Here is how encoder_destroy() is invoked:\n\naom_codec_err_t aom_codec_destroy(aom_codec_ctx_t *ctx) {\n  if (!ctx) {\n    return AOM_CODEC_INVALID_PARAM;\n  }\n  if (!ctx-\u003eiface || !ctx-\u003epriv) {\n    ctx-\u003eerr \u003d AOM_CODEC_ERROR;\n    return AOM_CODEC_ERROR;\n  }\n  ctx-\u003eiface-\u003edestroy((aom_codec_alg_priv_t *)ctx-\u003epriv);\n  ctx-\u003eiface \u003d NULL;\n  ctx-\u003ename \u003d NULL;\n  ctx-\u003epriv \u003d NULL;\n  ctx-\u003eerr \u003d AOM_CODEC_OK;\n  return AOM_CODEC_OK;\n}\n\nSo ctx-\u003epriv is freed by encoder_destroy(), and then aom_codec_destroy() sets ctx-\u003epriv to NULL.",
      "parentUuid": "57d951c8_b3f7cfcb",
      "revId": "768e40939ddeea313af10199fc396be4088dee93",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dbb929f6_0cb53e23",
        "filename": "av1/av1_cx_iface.c",
        "patchSetId": 11
      },
      "lineNbr": 3385,
      "author": {
        "id": 9545
      },
      "writtenOn": "2021-07-21T00:20:06Z",
      "side": 1,
      "message": "Note: Please make the same change to the similar error messages below.\n\nChange \"space\" to \"memory\".",
      "range": {
        "startLine": 3385,
        "startChar": 35,
        "endLine": 3385,
        "endChar": 40
      },
      "revId": "768e40939ddeea313af10199fc396be4088dee93",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "20684f4b_34c0bc58",
        "filename": "av1/av1_cx_iface.c",
        "patchSetId": 11
      },
      "lineNbr": 3385,
      "author": {
        "id": 7525
      },
      "writtenOn": "2021-07-21T18:03:04Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "dbb929f6_0cb53e23",
      "range": {
        "startLine": 3385,
        "startChar": 35,
        "endLine": 3385,
        "endChar": 40
      },
      "revId": "768e40939ddeea313af10199fc396be4088dee93",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "abfb935d_d111d854",
        "filename": "av1/av1_cx_iface.c",
        "patchSetId": 11
      },
      "lineNbr": 3713,
      "author": {
        "id": 9545
      },
      "writtenOn": "2021-07-21T00:20:06Z",
      "side": 1,
      "message": "Nit: Ideally we should figure out a way to return AOM_CODEC_MEM_ERROR instead of AOM_CODEC_INVALID_PARAM after an allocate_and_set_string() failure.",
      "revId": "768e40939ddeea313af10199fc396be4088dee93",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b24d44a0_5643fbdf",
        "filename": "av1/av1_cx_iface.c",
        "patchSetId": 11
      },
      "lineNbr": 3713,
      "author": {
        "id": 7525
      },
      "writtenOn": "2021-07-21T18:03:04Z",
      "side": 1,
      "message": "Added a variable to store the return value and check it here.",
      "parentUuid": "abfb935d_d111d854",
      "revId": "768e40939ddeea313af10199fc396be4088dee93",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    }
  ]
}