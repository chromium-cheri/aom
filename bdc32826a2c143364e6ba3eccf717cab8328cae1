{
  "comments": [
    {
      "key": {
        "uuid": "bf9961c3_177bd308",
        "filename": "av1/decoder/obu.c",
        "patchSetId": 3
      },
      "lineNbr": 615,
      "author": {
        "id": 14148
      },
      "writtenOn": "2020-07-03T20:50:45Z",
      "side": 1,
      "message": "From what I remember sz value includes the trailing byte 0x80 in the count, so I think an improbable case of an input as \"0xFF 0x80\" where 0x80 is the trailing byte, could be accepted here. Perhaps an if (sz \u003c\u003d 2) could be used or checking for the trailing byte presence.\nMaybe this is validated before this function but just wanted to mention it.",
      "range": {
        "startLine": 615,
        "startChar": 4,
        "endLine": 615,
        "endChar": 16
      },
      "revId": "bdc32826a2c143364e6ba3eccf717cab8328cae1",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6abae64f_f8dcc1bd",
        "filename": "av1/decoder/obu.c",
        "patchSetId": 3
      },
      "lineNbr": 615,
      "author": {
        "id": 9545
      },
      "writtenOn": "2020-07-03T21:46:48Z",
      "side": 1,
      "message": "Yes, the sz value includes the trailing byte 0x80 in the count.\n\nIf sz is 2 and the input is \"0xFF 0x80\", this function will read 0xFF\nas itu_t_t35_country_code, and then read 0x80 as\nitu_t_t35_country_code_extension_byte. It sets country_code_size to 2.\n\nThen it calls get_last_nonzero_byte_index(), which returns end_index\u003d1.\n\nSince end_index \u003c country_code_size, it calls aom_internal_error() with\nthe error message \"No trailing bits found in ITU-T T.35 metadata OBU\".\nSo this input will not be accepted.\n\nNote: An alternative way to parse the input is to first look for the\ntrailing byte and extract the payload data. For the input \"0xFF 0x80\",\nwe would say the payload data is \"0xFF\". Then we would parse the payload,\nand report the error \"itu_t_t35_country_code_extension_byte is missing\".\n\nIt seems that your original code was trying to parse the input in this\nalternative way. The original code has trouble with one-byte input like\n\"0x80\" or \"0x33\". It will call alloc_read_metadata() with sz\u003dbytes_read(\u003d0),\nwhich fails and reports the confusing AOM_CODEC_MEM_ERROR error.",
      "parentUuid": "bf9961c3_177bd308",
      "range": {
        "startLine": 615,
        "startChar": 4,
        "endLine": 615,
        "endChar": 16
      },
      "revId": "bdc32826a2c143364e6ba3eccf717cab8328cae1",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b1bdd513_570efe91",
        "filename": "av1/decoder/obu.c",
        "patchSetId": 3
      },
      "lineNbr": 615,
      "author": {
        "id": 14148
      },
      "writtenOn": "2020-07-03T23:25:28Z",
      "side": 1,
      "message": "Yes! Thank you for the fix and I get the idea of the change.",
      "parentUuid": "6abae64f_f8dcc1bd",
      "range": {
        "startLine": 615,
        "startChar": 4,
        "endLine": 615,
        "endChar": 16
      },
      "revId": "bdc32826a2c143364e6ba3eccf717cab8328cae1",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    }
  ]
}