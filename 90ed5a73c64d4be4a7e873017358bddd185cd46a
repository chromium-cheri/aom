{
  "comments": [
    {
      "key": {
        "uuid": "2a099379_6186b652",
        "filename": "av1/common/arm/cfl_neon.c",
        "patchSetId": 24
      },
      "lineNbr": 257,
      "author": {
        "id": 5075
      },
      "writtenOn": "2018-04-25T01:48:48Z",
      "side": 1,
      "message": "Out of curiosity, why can\u0027t you use vctgz/vcltz on ARMv7? The instruction set certainly supports it.",
      "revId": "90ed5a73c64d4be4a7e873017358bddd185cd46a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e0155441_fe20aecc",
        "filename": "av1/common/arm/cfl_neon.c",
        "patchSetId": 24
      },
      "lineNbr": 257,
      "author": {
        "id": 7105
      },
      "writtenOn": "2018-04-25T15:50:30Z",
      "side": 1,
      "message": "It would appear that the vcgtz and vcltz intrinsics are only available on A64 (see https://developer.arm.com/technologies/neon/intrinsics). However, it does appear that in assembly, the instruction if available on ARMv7.\nNote that, based on the documentation, vcgtz_s16 gets translated to CMGT Vd.4H,Vn.4H,#0",
      "parentUuid": "2a099379_6186b652",
      "revId": "90ed5a73c64d4be4a7e873017358bddd185cd46a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ecd23c6f_76915236",
        "filename": "av1/common/arm/cfl_neon.c",
        "patchSetId": 24
      },
      "lineNbr": 257,
      "author": {
        "id": 5075
      },
      "writtenOn": "2018-04-26T00:02:27Z",
      "side": 1,
      "message": "Looking up the timings, at least for older ARMv7 chips, VSHR has 1...2 cycles less latency, also (which I guess makes vcltz completely useless? not sure if that\u0027s the same on newer chips or ARM64, but it was probably free to add to the ISA once you had it for floating-point).",
      "parentUuid": "e0155441_fe20aecc",
      "revId": "90ed5a73c64d4be4a7e873017358bddd185cd46a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9da0fb00_a1c5f161",
        "filename": "av1/common/arm/cfl_neon.c",
        "patchSetId": 24
      },
      "lineNbr": 257,
      "author": {
        "id": 7105
      },
      "writtenOn": "2018-04-26T02:32:15Z",
      "side": 1,
      "message": "Lines 252 to 259 have been replaced with const int16x4_t mask \u003d vshrq_n_s16(b, 15); \nFewer operations and the same path for ARMv7 and ARMv8 so  this is win-win",
      "parentUuid": "ecd23c6f_76915236",
      "revId": "90ed5a73c64d4be4a7e873017358bddd185cd46a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f51d8d24_3bbb8d48",
        "filename": "av1/common/arm/cfl_neon.c",
        "patchSetId": 24
      },
      "lineNbr": 260,
      "author": {
        "id": 5075
      },
      "writtenOn": "2018-04-25T01:48:48Z",
      "side": 1,
      "message": "Multiplies have a very long latency in NEON. You can do much better than this if you don\u0027t care about preserving the current behavior when b is zero (which I don\u0027t think you do, that behavior does not even match what the comment on the function says).\n\nSpecifically:\nmask \u003d vreinterpret_s16_u16(vcltz_s16(b)); //alternatively vshr_s16(b, 15);\nreturn vreinterpret_s16_u16(veor_s16(vadd_s16(a, mask), mask));",
      "revId": "90ed5a73c64d4be4a7e873017358bddd185cd46a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "bc8d5db4_b2d601e3",
        "filename": "av1/common/arm/cfl_neon.c",
        "patchSetId": 24
      },
      "lineNbr": 260,
      "author": {
        "id": 7105
      },
      "writtenOn": "2018-04-25T15:50:30Z",
      "side": 1,
      "message": "You\u0027re right, I had not copied the whole comment from the Intel documentation. This part was missing: \"Element in a are zeroed out when the corresponding element in b is zero\". I\u0027ve expressed this concern in the comments of the function\n\nLet\u0027s use vshr_n_s16(b, 15), this removes the need for the #if __ARM_ARCH \u003e\u003d 8 block.\n\nI noticed some issues with INT16_MIN, so I changed vadd for vaddq, now negating INT16_MIN results in INT16_MAX. This situation cannot occur in practice.",
      "parentUuid": "f51d8d24_3bbb8d48",
      "revId": "90ed5a73c64d4be4a7e873017358bddd185cd46a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c5673489_748ee9bd",
        "filename": "av1/common/arm/cfl_neon.c",
        "patchSetId": 24
      },
      "lineNbr": 260,
      "author": {
        "id": 5075
      },
      "writtenOn": "2018-04-26T00:02:27Z",
      "side": 1,
      "message": "vqadd*() has one cycle more latency than vadd*() (again, on the older ARMv7 chips for which I had the TRMs handy). So probably not worth using if INT16_MIN can\u0027t happen in practice. Given that we are now only using this function on the result of the product of two non-negative numbers, I agree with you that it can\u0027t. It\u0027s still good practice to document the behavior for INT16_MIN, of course (i.e., without vqadd*(), INT16_MIN stays INT16_MIN).",
      "parentUuid": "bc8d5db4_b2d601e3",
      "revId": "90ed5a73c64d4be4a7e873017358bddd185cd46a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "06fe69be_832986d2",
        "filename": "av1/common/arm/cfl_neon.c",
        "patchSetId": 24
      },
      "lineNbr": 260,
      "author": {
        "id": 7105
      },
      "writtenOn": "2018-04-26T02:32:15Z",
      "side": 1,
      "message": "Done\n\nBefore change \nNEON/CFLPredictTest (Odroid C2, Cortex-A53)\n4x4: C time \u003d 4946 us, SIMD time \u003d 2411 us (~2.1x)\n8x8: C time \u003d 20177 us, SIMD time \u003d 4481 us (~4.5x)\n16x16: C time \u003d 31658 us, SIMD time \u003d 13184 us (~2.4x)\n32x32: C time \u003d 116067 us, SIMD time \u003d 49727 us (~2.3x)\n\t\t\nNEON/CFLPredictHBDTest\n4x4: C time \u003d 4939 us, SIMD time \u003d 1985 us (~2.5x)\n8x8: C time \u003d 20273 us, SIMD time \u003d 3936 us (~5.2x)\n16x16: C time \u003d 29667 us, SIMD time \u003d 15360 us (~1.9x)\n32x32: C time \u003d 108565 us, SIMD time \u003d 58748 us (~1.8x)\n\nAfter change:\nNEON/CFLPredictTest (Odroid C2, Cortex-A53)\n4x4: C time \u003d 4929 us, SIMD time \u003d 2326 us (~2.1x)\n8x8: C time \u003d 20136 us, SIMD time \u003d 4310 us (~4.7x)\n16x16: C time \u003d 31607 us, SIMD time \u003d 11538 us (~2.7x)\n32x32: C time \u003d 116004 us, SIMD time \u003d 42957 us (~2.7x)\n\nNEON/CFLPredictHBDTest\n4x4: C time \u003d 4939 us, SIMD time \u003d 1899 us (~2.6x)\n8x8: C time \u003d 20273 us, SIMD time \u003d 3764 us (~5.4x)\n16x16: C time \u003d 29645 us, SIMD time \u003d 14648 us (~2x)\n32x32: C time \u003d 108542 us, SIMD time \u003d 55977 us (~1.9x)",
      "parentUuid": "c5673489_748ee9bd",
      "revId": "90ed5a73c64d4be4a7e873017358bddd185cd46a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6e2903ba_c2fc77e5",
        "filename": "av1/common/arm/cfl_neon.c",
        "patchSetId": 24
      },
      "lineNbr": 265,
      "author": {
        "id": 5075
      },
      "writtenOn": "2018-04-25T01:48:48Z",
      "side": 1,
      "message": "See above.",
      "revId": "90ed5a73c64d4be4a7e873017358bddd185cd46a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6d4aae90_412b1711",
        "filename": "av1/common/arm/cfl_neon.c",
        "patchSetId": 24
      },
      "lineNbr": 265,
      "author": {
        "id": 7105
      },
      "writtenOn": "2018-04-25T15:50:30Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "6e2903ba_c2fc77e5",
      "revId": "90ed5a73c64d4be4a7e873017358bddd185cd46a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "200accbd_80e20620",
        "filename": "av1/common/arm/cfl_neon.c",
        "patchSetId": 24
      },
      "lineNbr": 281,
      "author": {
        "id": 5075
      },
      "writtenOn": "2018-04-25T01:48:48Z",
      "side": 1,
      "message": "All you need here is for ac_sign to be negative if the signs of alpha_sign and ac_q3 differ, and non-negative if they are the same. So this reduces to\n\nac_sign \u003d vreinterpret_s16_u16(veor_s16(alpha_sign, ac_q3));\n\nThat saves two operations even over the simplified implementation of vsign_s16 proposed above.",
      "revId": "90ed5a73c64d4be4a7e873017358bddd185cd46a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8f76415b_f02ba456",
        "filename": "av1/common/arm/cfl_neon.c",
        "patchSetId": 24
      },
      "lineNbr": 281,
      "author": {
        "id": 7105
      },
      "writtenOn": "2018-04-25T21:15:30Z",
      "side": 1,
      "message": "Great find! This also applied to predict_w8",
      "parentUuid": "200accbd_80e20620",
      "revId": "90ed5a73c64d4be4a7e873017358bddd185cd46a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "23146d26_bf0c1d42",
        "filename": "av1/common/arm/cfl_neon.c",
        "patchSetId": 24
      },
      "lineNbr": 309,
      "author": {
        "id": 5075
      },
      "writtenOn": "2018-04-25T01:48:48Z",
      "side": 1,
      "message": "ARMv7 also has VQMOVUN.S16, so I\u0027m a little confused why you\u0027re doing this in two steps (first vqshluq_n_s16(..., 0) and then vqmovn_u16()).\n\nIt\u0027s also a little weird that this function does the unsigned saturation/narrowing inside of it, while the other predict_w\u003cN\u003e functions do not. The reader doesn\u0027t find out why until they get to the hbd implementation below. I think this function should have a different name that indicates the extra functionality somehow. It may even be worth making functions for the other sizes that also include the saturation/narrowing and also follow the same naming scheme, to make cfl_predict_lbd_neon() look more consistent, but that\u0027s up to you.",
      "revId": "90ed5a73c64d4be4a7e873017358bddd185cd46a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d254b767_15111093",
        "filename": "av1/common/arm/cfl_neon.c",
        "patchSetId": 24
      },
      "lineNbr": 309,
      "author": {
        "id": 7105
      },
      "writtenOn": "2018-04-25T21:15:30Z",
      "side": 1,
      "message": "It would appear that the vqmovun_high intrinsic is only available on A64 (see https://developer.arm.com/technologies/neon/intrinsics).",
      "parentUuid": "23146d26_bf0c1d42",
      "revId": "90ed5a73c64d4be4a7e873017358bddd185cd46a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "68bdcac8_86e11ce7",
        "filename": "av1/common/arm/cfl_neon.c",
        "patchSetId": 24
      },
      "lineNbr": 309,
      "author": {
        "id": 5075
      },
      "writtenOn": "2018-04-26T00:02:27Z",
      "side": 1,
      "message": "Yes, but vqmovun_s16() is available on both. So two of those followed by vcombine_u8() should do, right? Assuming the register allocator makes the vcombine_u8() disappear, that\u0027s fewer instructions on both architectures, or did I misunderstand something?",
      "parentUuid": "d254b767_15111093",
      "revId": "90ed5a73c64d4be4a7e873017358bddd185cd46a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "14b15014_c6c4ae28",
        "filename": "av1/common/arm/cfl_neon.c",
        "patchSetId": 24
      },
      "lineNbr": 309,
      "author": {
        "id": 7105
      },
      "writtenOn": "2018-04-26T02:32:15Z",
      "side": 1,
      "message": "I did not know about vqmovun, all occurences of vqmovn should be changed to vqmovun\nBefore change:\nNEON/CFLPredictTest (Odroid C2, Cortex-A53)\n4x4: C time \u003d 4946 us, SIMD time \u003d 2411 us (~2.1x)\n8x8: C time \u003d 20177 us, SIMD time \u003d 4481 us (~4.5x)\n16x16: C time \u003d 31658 us, SIMD time \u003d 13184 us (~2.4x)\n32x32: C time \u003d 116067 us, SIMD time \u003d 49727 us (~2.3x)\nAfter change:\n4x4: C time \u003d 4929 us, SIMD time \u003d 1985 us (~2.5x)\n8x8: C time \u003d 20136 us, SIMD time \u003d 3627 us (~5.6x)\n16x16: C time \u003d 31631 us, SIMD time \u003d 10829 us (~2.9x)\n32x32: C time \u003d 116008 us, SIMD time \u003d 40206 us (~2.9x)",
      "parentUuid": "68bdcac8_86e11ce7",
      "revId": "90ed5a73c64d4be4a7e873017358bddd185cd46a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    }
  ]
}