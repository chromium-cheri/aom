{
  "comments": [
    {
      "key": {
        "uuid": "2a099379_6186b652",
        "filename": "av1/common/arm/cfl_neon.c",
        "patchSetId": 24
      },
      "lineNbr": 257,
      "author": {
        "id": 5075
      },
      "writtenOn": "2018-04-25T01:48:48Z",
      "side": 1,
      "message": "Out of curiosity, why can\u0027t you use vctgz/vcltz on ARMv7? The instruction set certainly supports it.",
      "revId": "90ed5a73c64d4be4a7e873017358bddd185cd46a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e0155441_fe20aecc",
        "filename": "av1/common/arm/cfl_neon.c",
        "patchSetId": 24
      },
      "lineNbr": 257,
      "author": {
        "id": 7105
      },
      "writtenOn": "2018-04-25T15:50:30Z",
      "side": 1,
      "message": "It would appear that the vcgtz and vcltz intrinsics are only available on A64 (see https://developer.arm.com/technologies/neon/intrinsics). However, it does appear that in assembly, the instruction if available on ARMv7.\nNote that, based on the documentation, vcgtz_s16 gets translated to CMGT Vd.4H,Vn.4H,#0",
      "parentUuid": "2a099379_6186b652",
      "revId": "90ed5a73c64d4be4a7e873017358bddd185cd46a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f51d8d24_3bbb8d48",
        "filename": "av1/common/arm/cfl_neon.c",
        "patchSetId": 24
      },
      "lineNbr": 260,
      "author": {
        "id": 5075
      },
      "writtenOn": "2018-04-25T01:48:48Z",
      "side": 1,
      "message": "Multiplies have a very long latency in NEON. You can do much better than this if you don\u0027t care about preserving the current behavior when b is zero (which I don\u0027t think you do, that behavior does not even match what the comment on the function says).\n\nSpecifically:\nmask \u003d vreinterpret_s16_u16(vcltz_s16(b)); //alternatively vshr_s16(b, 15);\nreturn vreinterpret_s16_u16(veor_s16(vadd_s16(a, mask), mask));",
      "revId": "90ed5a73c64d4be4a7e873017358bddd185cd46a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "bc8d5db4_b2d601e3",
        "filename": "av1/common/arm/cfl_neon.c",
        "patchSetId": 24
      },
      "lineNbr": 260,
      "author": {
        "id": 7105
      },
      "writtenOn": "2018-04-25T15:50:30Z",
      "side": 1,
      "message": "You\u0027re right, I had not copied the whole comment from the Intel documentation. This part was missing: \"Element in a are zeroed out when the corresponding element in b is zero\". I\u0027ve expressed this concern in the comments of the function\n\nLet\u0027s use vshr_n_s16(b, 15), this removes the need for the #if __ARM_ARCH \u003e\u003d 8 block.\n\nI noticed some issues with INT16_MIN, so I changed vadd for vaddq, now negating INT16_MIN results in INT16_MAX. This situation cannot occur in practice.",
      "parentUuid": "f51d8d24_3bbb8d48",
      "revId": "90ed5a73c64d4be4a7e873017358bddd185cd46a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6e2903ba_c2fc77e5",
        "filename": "av1/common/arm/cfl_neon.c",
        "patchSetId": 24
      },
      "lineNbr": 265,
      "author": {
        "id": 5075
      },
      "writtenOn": "2018-04-25T01:48:48Z",
      "side": 1,
      "message": "See above.",
      "revId": "90ed5a73c64d4be4a7e873017358bddd185cd46a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6d4aae90_412b1711",
        "filename": "av1/common/arm/cfl_neon.c",
        "patchSetId": 24
      },
      "lineNbr": 265,
      "author": {
        "id": 7105
      },
      "writtenOn": "2018-04-25T15:50:30Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "6e2903ba_c2fc77e5",
      "revId": "90ed5a73c64d4be4a7e873017358bddd185cd46a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "200accbd_80e20620",
        "filename": "av1/common/arm/cfl_neon.c",
        "patchSetId": 24
      },
      "lineNbr": 281,
      "author": {
        "id": 5075
      },
      "writtenOn": "2018-04-25T01:48:48Z",
      "side": 1,
      "message": "All you need here is for ac_sign to be negative if the signs of alpha_sign and ac_q3 differ, and non-negative if they are the same. So this reduces to\n\nac_sign \u003d vreinterpret_s16_u16(veor_s16(alpha_sign, ac_q3));\n\nThat saves two operations even over the simplified implementation of vsign_s16 proposed above.",
      "revId": "90ed5a73c64d4be4a7e873017358bddd185cd46a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "23146d26_bf0c1d42",
        "filename": "av1/common/arm/cfl_neon.c",
        "patchSetId": 24
      },
      "lineNbr": 309,
      "author": {
        "id": 5075
      },
      "writtenOn": "2018-04-25T01:48:48Z",
      "side": 1,
      "message": "ARMv7 also has VQMOVUN.S16, so I\u0027m a little confused why you\u0027re doing this in two steps (first vqshluq_n_s16(..., 0) and then vqmovn_u16()).\n\nIt\u0027s also a little weird that this function does the unsigned saturation/narrowing inside of it, while the other predict_w\u003cN\u003e functions do not. The reader doesn\u0027t find out why until they get to the hbd implementation below. I think this function should have a different name that indicates the extra functionality somehow. It may even be worth making functions for the other sizes that also include the saturation/narrowing and also follow the same naming scheme, to make cfl_predict_lbd_neon() look more consistent, but that\u0027s up to you.",
      "revId": "90ed5a73c64d4be4a7e873017358bddd185cd46a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    }
  ]
}