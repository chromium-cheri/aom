{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "8825b649_6fc6986c",
        "filename": "av1/common/alloccommon.c",
        "patchSetId": 8
      },
      "lineNbr": 70,
      "author": {
        "id": 9545
      },
      "writtenOn": "2021-04-12T21:41:02Z",
      "side": 1,
      "message": "We don\u0027t need to check if cm-\u003eseq_params.subsampling_y has changed because it is not used in the calculation of the linebuf[i] size. See line 100. Only cm-\u003eseq_params.subsampling_x is used.",
      "revId": "04af8c26561bcd9099cde357edadf825512182d4",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0571e1d9_b97655a2",
        "filename": "av1/common/av1_common_int.h",
        "patchSetId": 8
      },
      "lineNbr": 209,
      "author": {
        "id": 9545
      },
      "writtenOn": "2021-04-12T21:41:02Z",
      "side": 1,
      "message": "Instead of storing these values, we can store the sizes of the linebuf[i] buffers:\n\n   uint16_t *linebuf[MAX_MB_PLANE];        /*!\u003c CDEF top \u0026 bottom line buffer */\n+  int linebuf_size[MAX_MB_PLANE];\n\nThen, av1_alloc_cdef_linebuf() can compute the new size of linebuf[i]. If the new size of linebuf[i] is different from linebuf_size[i], then we free the current linebuf[i], reallocate it with the new size, and set linebuf_size[i] to the new size.\n\nAn advantage of this approach is that we don\u0027t need to figure out which fields of the sequence header OBU we need to save.",
      "range": {
        "startLine": 204,
        "startChar": 0,
        "endLine": 209,
        "endChar": 67
      },
      "revId": "04af8c26561bcd9099cde357edadf825512182d4",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    }
  ]
}