{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "10c75f29_d37a3d3d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 6245
      },
      "writtenOn": "2023-01-12T17:13:42Z",
      "side": 1,
      "message": "Hi Yunqing,\nIn this CL, we optimized the code related to temporal filtering. In the parent version, weight is calculated using exp(). exp() is called ‘tf_ctx-\u003enum_frames’ times for each pixel in the frame to be filtered. In this CL, we replaced exp() by a lookup and enabled this optimization for speed\u003d5,6. \n\nFor exp(x) in parent version, x is in the range of 0 to 7. Initially, we implemented a lookup table with 1000 entries. Hence the index for lookup would be x*1000/7. To avoid this division, we created the lookup with 995 (7 * 142 +1)  entries that maps to 0 to 7 range. Thus, index can be calculated x * 142. \n\nWe also modified TemporalFilterTest unit-test accordingly. As second argument parameter of this unit-test is unused/ignored, we modified the same as different speed feature settings.  \n\nPlease check the borg results for good encoding mode below:\n\n```\n                    Instruction Count      BD-Rate Loss(%)\n   cpu   Testset       Reduction(%)    avg.psnr   ovr.psnr    ssim\n    5     LOWRES2       3.236            0.0255    0.0357    0.0511\n    5     MIDRES2       4.315            0.0054   -0.0004   -0.0203\n    5      HDRES2       5.293           -0.0779   -0.0723   -0.1114\n    6     LOWRES2       1.833            0.0375    0.0335    0.0362\n    6     MIDRES2       4.014            0.0231    0.0242    0.0711\n    6      HDRES2       4.876           -0.0128   -0.0131   -0.0003\n```\n\nThe instruction count reduction specified has been measured using command:\n $ perf stat -e instructions:u ./aomenc …\n\nWe verified that CL is bit-exact for speed\u003d4 with a minor instruction count increase of 0.02%. This minor increase could be due to the if () condition introduced in apply_temporal_filter() function based on speed feature setting.\n\nPlease let us know your opinion on this CL\n\nRegards,\nRanjit",
      "revId": "45d6ea6327d968e0f9debaabe6ab6cda397aa2c2",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "71905f96_d074a0f1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 5185
      },
      "writtenOn": "2023-01-12T19:52:54Z",
      "side": 1,
      "message": "Sounds like a good optimization! Need some time to go over the details. You mentioned \"For exp(x) in parent version, x is in the range of 0 to 7.\" Can you explain the calculation for that?\n\nAlso, other speeds could also benefit from this.",
      "parentUuid": "10c75f29_d37a3d3d",
      "revId": "45d6ea6327d968e0f9debaabe6ab6cda397aa2c2",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7b4c6b00_5ae4108c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 9823
      },
      "writtenOn": "2023-01-12T22:13:58Z",
      "side": 1,
      "message": "Alternatively, we could use the approx_exp function in aom/av1/encoder/ml.c instead of a look up table. Which one performs better will depend on how the LUT is cached and the accuracy of the linear approximation.",
      "revId": "45d6ea6327d968e0f9debaabe6ab6cda397aa2c2",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "66b028b3_625bd92f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 6245
      },
      "writtenOn": "2023-01-13T15:14:01Z",
      "side": 1,
      "message": "Ack. We did a quick test by using approx_exp() from ml.c after typecasting input to float (scaled_error is of type double). The speed and quality data is summarized below. \n\n```\n               Instruction Count        BD-Rate Loss(%)       \ncpu Resolution   Reduction(%)    avg.psnr   ovr.psnr    ssim  \n 5     LOWRES2      3.147         0.0724     0.0666    0.0914\n 5     MIDRES2      4.197         0.0673     0.0344    0.0145\n 5      HDRES2      5.258         0.0208     0.0212    0.0099\n 6     LOWRES2      1.815         0.0167     0.0053   -0.0009\n 6     MIDRES2      3.893        -0.0127    -0.0093    0.0219\n 6      HDRES2      4.762         0.0010    -0.0089   -0.0178\n```\n\nThe speed-up seems to be on par with current CL with a slightly higher BD-Rate loss. When we tested for few specific values of scaled_error, we observed that approx_exp() has more error w.r.t exp() than current CL (overall) as given below.\n\n```\nscaled_error\u003d0.12186102972877232\nExpected value    - 885\napprox_exp method - 908\ncurrent CL        - 887\n\nscaled_error\u003d0.0035000000000000001 (little lesser than 1/142/2 where maximum error is possible with current CL)\nExpected value    - 996\napprox_exp method - 993\ncurrent CL        - 1000\n\nscaled_error\u003d0.5\nExpected value    - 606\napprox_exp method - 635\ncurrent CL        - 606\n\n```",
      "parentUuid": "7b4c6b00_5ae4108c",
      "revId": "45d6ea6327d968e0f9debaabe6ab6cda397aa2c2",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1b02f47f_eb90c323",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 6245
      },
      "writtenOn": "2023-01-13T15:14:01Z",
      "side": 1,
      "message": "Hi Yunqing, Chi-Yo,\n\nBased on the results, we observe that the current approach gives good gains. \nHowever based on the suggestions and few more ideas such as range reduction algorithm and algorithmic modifications to reduce exp() calls for better SIMD performance (SSE and AVX2), we have plans to further study quality/speed impact, feasibility of SIMD implementation (SSE and AVX2) and C vs SIMD mismatch (due to floating point implementation) to assess the further gains/fine tuning possible for speed\u003d5,6 and other presets as well.\nPlease let us know your opinion.\n\nRegards,\nRanjit",
      "revId": "45d6ea6327d968e0f9debaabe6ab6cda397aa2c2",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ed6c92ed_eec17160",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 6245
      },
      "writtenOn": "2023-01-13T15:14:01Z",
      "side": 1,
      "message": "Ack. The weight is calculated as exp(-scaled_error) - Refer to code snippet A. scaled_error is obtained by weighing different SSE values and is clipped to 7 - Refer to code snippet B. From the code study we understood that scaled_error is positive and should be between 0 and 7. Hence we added an assert on the final index accordingly.",
      "parentUuid": "71905f96_d074a0f1",
      "revId": "45d6ea6327d968e0f9debaabe6ab6cda397aa2c2",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    }
  ]
}