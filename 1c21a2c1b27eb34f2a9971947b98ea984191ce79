{
  "comments": [
    {
      "key": {
        "uuid": "8dd632c7_1e88795e",
        "filename": "av1/common/quant_common.c",
        "patchSetId": 9
      },
      "lineNbr": 398,
      "author": {
        "id": 11876
      },
      "writtenOn": "2020-06-25T04:08:10Z",
      "side": 1,
      "message": "this case should not be allowed for 8 bit, right? if yes, then we should add an assertion here.",
      "range": {
        "startLine": 398,
        "startChar": 30,
        "endLine": 398,
        "endChar": 32
      },
      "revId": "1c21a2c1b27eb34f2a9971947b98ea984191ce79",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8e3df4ea_562cc778",
        "filename": "av1/common/quant_common.c",
        "patchSetId": 9
      },
      "lineNbr": 398,
      "author": {
        "id": 16052
      },
      "writtenOn": "2020-06-25T05:16:51Z",
      "side": 1,
      "message": "Thanks for the comment Ryan. Yes, it should not be allowed. I will add an assertion here.",
      "parentUuid": "8dd632c7_1e88795e",
      "range": {
        "startLine": 398,
        "startChar": 30,
        "endLine": 398,
        "endChar": 32
      },
      "revId": "1c21a2c1b27eb34f2a9971947b98ea984191ce79",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8d2e777f_16c94f93",
        "filename": "av1/common/quant_common.c",
        "patchSetId": 9
      },
      "lineNbr": 456,
      "author": {
        "id": 11876
      },
      "writtenOn": "2020-06-25T04:08:10Z",
      "side": 1,
      "message": "same comment as above",
      "range": {
        "startLine": 456,
        "startChar": 30,
        "endLine": 456,
        "endChar": 31
      },
      "revId": "1c21a2c1b27eb34f2a9971947b98ea984191ce79",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1db8f9b8_23c5b7e5",
        "filename": "av1/common/quant_common.c",
        "patchSetId": 9
      },
      "lineNbr": 456,
      "author": {
        "id": 16052
      },
      "writtenOn": "2020-06-25T05:16:51Z",
      "side": 1,
      "message": "An assertion will be added here.",
      "parentUuid": "8d2e777f_16c94f93",
      "range": {
        "startLine": 456,
        "startChar": 30,
        "endLine": 456,
        "endChar": 31
      },
      "revId": "1c21a2c1b27eb34f2a9971947b98ea984191ce79",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "caa4bd03_7050901b",
        "filename": "av1/encoder/av1_quantize.c",
        "patchSetId": 9
      },
      "lineNbr": 884,
      "author": {
        "id": 11876
      },
      "writtenOn": "2020-06-25T04:08:10Z",
      "side": 1,
      "message": "what is the purpose of these two offset array? are they supposed to be the same size?",
      "range": {
        "startLine": 884,
        "startChar": 1,
        "endLine": 884,
        "endChar": 3
      },
      "revId": "1c21a2c1b27eb34f2a9971947b98ea984191ce79",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e1d5eb12_ed3d8c13",
        "filename": "av1/encoder/av1_quantize.c",
        "patchSetId": 9
      },
      "lineNbr": 884,
      "author": {
        "id": 16052
      },
      "writtenOn": "2020-06-25T05:16:51Z",
      "side": 1,
      "message": "The two offset arrays are used as an encoder feature to replicate the 4*q_step \u0026 16*q_step for 10/12 internal bit-depth respectively. It tries to achieve the required increase in q_step for 10/12 internal bit-depth for a particular cq-level by shifting the q_index. Ideally, if the q_step doubles every 30 q_index, only two values 60 \u0026 120 are needed for 10/12 internal bit-depth respectively. But, due to the linear portion from qindex [1,29] an offset table is necessary. \n\nE.g. when cq-level\u003d1 :\n\n8-bit : function av1_quantizer_to_qindex(..) returns quantizer_to_qindex[1];\n\n10-bit : function av1_quantizer_to_qindex(..) returns (quantizer_to_qindex[1] + qindex_10b_offset[1]);\n\n12-bit : function av1_quantizer_to_qindex(..) returns (quantizer_to_qindex[1] + qindex_12b_offset[1]);",
      "parentUuid": "caa4bd03_7050901b",
      "range": {
        "startLine": 884,
        "startChar": 1,
        "endLine": 884,
        "endChar": 3
      },
      "revId": "1c21a2c1b27eb34f2a9971947b98ea984191ce79",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "97e0f15f_68092e5d",
        "filename": "av1/encoder/av1_quantize.c",
        "patchSetId": 9
      },
      "lineNbr": 884,
      "author": {
        "id": 11876
      },
      "writtenOn": "2020-06-25T20:17:28Z",
      "side": 1,
      "message": "do you mean we will still have cq_level in the range of [0, 63] but they will map to different actual q_index for 8/10/12 bits? the other option would be extend the cq_level range for 10/12 bit video to a larger range. not sure which way is better. also, you didn\u0027t answer why these two arrays have different number of entries.",
      "parentUuid": "e1d5eb12_ed3d8c13",
      "range": {
        "startLine": 884,
        "startChar": 1,
        "endLine": 884,
        "endChar": 3
      },
      "revId": "1c21a2c1b27eb34f2a9971947b98ea984191ce79",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5cb245d4_c2ec90a7",
        "filename": "av1/encoder/av1_quantize.c",
        "patchSetId": 9
      },
      "lineNbr": 884,
      "author": {
        "id": 16052
      },
      "writtenOn": "2020-06-25T20:35:03Z",
      "side": 1,
      "message": "Yes, the cq-level is still in the range of [0,63] but they map to different q_index depending on bit depth. One could extend the cq_level range for 10/12 bit too, but then different values for cq-level will have to be used as input parameter for achieving similar bit rates for 8/10/12 bit unless a mapping is used by the encoder. \n\nRegarding the arrays, both of them have 64 offset entries corresponding to the 64 entries in the quantizer_to_qindex mapping table.",
      "parentUuid": "97e0f15f_68092e5d",
      "range": {
        "startLine": 884,
        "startChar": 1,
        "endLine": 884,
        "endChar": 3
      },
      "revId": "1c21a2c1b27eb34f2a9971947b98ea984191ce79",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6a11823d_36335be3",
        "filename": "build/cmake/aom_config_defaults.cmake",
        "patchSetId": 9
      },
      "lineNbr": 194,
      "author": {
        "id": 11876
      },
      "writtenOn": "2020-06-25T04:08:10Z",
      "side": 1,
      "message": "does this experiment depend on EXT_QUANT? if yes, you also need to set that when this experiment is enabled, it should automatically enable EXTQUANT experiment as well. you can search how EXTQUANT enables DELTA_DCQUANT experiment.",
      "range": {
        "startLine": 194,
        "startChar": 19,
        "endLine": 194,
        "endChar": 21
      },
      "revId": "1c21a2c1b27eb34f2a9971947b98ea984191ce79",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f426668f_f1463abb",
        "filename": "build/cmake/aom_config_defaults.cmake",
        "patchSetId": 9
      },
      "lineNbr": 194,
      "author": {
        "id": 16052
      },
      "writtenOn": "2020-06-25T05:16:51Z",
      "side": 1,
      "message": "Yes, it depends on EXT_QUANT. I will add a compile rule in the aom_experiment_deps.cmake file",
      "parentUuid": "6a11823d_36335be3",
      "range": {
        "startLine": 194,
        "startChar": 19,
        "endLine": 194,
        "endChar": 21
      },
      "revId": "1c21a2c1b27eb34f2a9971947b98ea984191ce79",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": true
    }
  ]
}