{
  "comments": [
    {
      "key": {
        "uuid": "41a36c15_ce456361",
        "filename": "CMakeLists.txt",
        "patchSetId": 2
      },
      "lineNbr": 252,
      "author": {
        "id": 5020
      },
      "writtenOn": "2016-10-26T02:23:45Z",
      "side": 1,
      "message": "order of the convenience libs don\u0027t matter for a lib target right?",
      "revId": "af9c0e2d7aa993552f578d9b742d3b562b18e590",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "41a36c15_d19b46fc",
        "filename": "CMakeLists.txt",
        "patchSetId": 2
      },
      "lineNbr": 252,
      "author": {
        "id": 5215
      },
      "writtenOn": "2016-10-27T14:29:31Z",
      "side": 1,
      "message": "It should not, but one of my TODOs is research into link order and any controls afforded by cmake. Hopefully there are some controls, or we can just set linker flags explicitly... though that would be rather lame.\n\nThere is a notion of source collections (instead of libs) if we run into trouble or the above doesn\u0027t pan out. The differences ends up something like the following.\n\n    # Now we have\n    add_libary(output_name $srcs)\n\n    # What we\u0027d end up with\n    add_library(output_name OBJECT $srcs)\n\nThe consequence is that the OBJECT targets are private within the AOM project. Users that want to just pull in libaom via cmake laziness would only see our libaom target... which might be exactly what we want.\n\nAnyway, cmake is pretty flexible, and this is here only because I need to hook the source list vars up to targets to actually see them in the IDE.",
      "parentUuid": "41a36c15_ce456361",
      "revId": "af9c0e2d7aa993552f578d9b742d3b562b18e590",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "86565a13_8b0d5158",
        "filename": "CMakeLists.txt",
        "patchSetId": 2
      },
      "lineNbr": 252,
      "author": {
        "id": 5020
      },
      "writtenOn": "2016-10-27T22:05:11Z",
      "side": 1,
      "message": "\u003e It should not, but one of my TODOs is research into link order and\n \u003e any controls afforded by cmake. Hopefully there are some controls,\n \u003e or we can just set linker flags explicitly... though that would be\n \u003e rather lame.\n \u003e \n\nwe should be able to set up some dependency if necessary. we have some builtin deps for webp carried over from the autoconf convenience libs.\n\n \u003e There is a notion of source collections (instead of libs) if we run\n \u003e into trouble or the above doesn\u0027t pan out. The differences ends up\n \u003e something like the following.\n \u003e \n \u003e # Now we have\n \u003e add_libary(output_name $srcs)\n \u003e \n \u003e # What we\u0027d end up with\n \u003e add_library(output_name OBJECT $srcs)\n \u003e \n \u003e The consequence is that the OBJECT targets are private within the\n \u003e AOM project. Users that want to just pull in libaom via cmake\n \u003e laziness would only see our libaom target... which might be exactly\n \u003e what we want.\n \u003e \n\nsounds like it.\n\n \u003e Anyway, cmake is pretty flexible, and this is here only because I\n \u003e need to hook the source list vars up to targets to actually see\n \u003e them in the IDE.",
      "parentUuid": "41a36c15_d19b46fc",
      "revId": "af9c0e2d7aa993552f578d9b742d3b562b18e590",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    }
  ]
}