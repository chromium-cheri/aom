{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "fe27b7ff_ee6d4f2e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 22433
      },
      "writtenOn": "2021-02-24T13:56:35Z",
      "side": 1,
      "message": "Hi Wan-Teh,\n\nWe have taken care of the review comments, given by you in the latest patchset (Patchset 3) and the patch is ready for review.\n\nWe see that Jenkins build has not started for the latest patchset. When we tried re-triggering the build for patchset 2, the build failed with error message \"Error cloning the remote repo\".\nCan you help us in retriggering the Jenkins build for patchset 3.\n\nHi Hui Su,\nPlease review the patch.\n\nThanks \u0026 Regards, \nAniket\n",
      "revId": "b916cb17098ddfa0c19891359210b00fe547ad40",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2b0180e8_7f7bc067",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 9545
      },
      "writtenOn": "2021-02-25T01:14:47Z",
      "side": 1,
      "message": "I just retriggered the Jenkins build for patchset 3.",
      "parentUuid": "fe27b7ff_ee6d4f2e",
      "revId": "b916cb17098ddfa0c19891359210b00fe547ad40",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1ea7ebf2_6ef0acbb",
        "filename": "av1/encoder/tokenize.h",
        "patchSetId": 3
      },
      "lineNbr": 35,
      "author": {
        "id": 9545
      },
      "writtenOn": "2021-02-25T01:37:08Z",
      "side": 1,
      "message": "Hi Aniket,\n\nJust FYI. I was curious about how bitfields are implemented. So I did some experiments with clang on x86-64 CPUs. The results are quite interesting.\n\nEither of the following two definitions of the struct generates the most compact code to read the members (one instruction each):\n\n  typedef struct {\n    uint8_t token : 3;\n    uint8_t reserved : 1;\n    int8_t color_ctx : 4;\n  } TokenExtra;\n\nor\n\n  typedef struct {\n    uint8_t token : 4;\n    int8_t color_ctx : 4;\n  } TokenExtra;\n\n1. color_ctx should be the last member so that it occupies the most significant four bits and an arithmetic right-shift by four bits will suffice because of the sign extension.\n\n2. The three bits of \u0027token\u0027 should occupy the least significant three bits so that they can be extracted with an AND instruction. This can be done by declaring \u0027token\u0027 as four bits or by inserting an unused bit.\n\nHere is my test file. Compile it with gcc or clang and inspect the assembly code in bitfield.s. Compare it with the current TokenExtra struct definition, which requires two instructions to read each member.\n\n$ cat bitfield.c\n#include \u003cstdint.h\u003e\n\ntypedef struct {\n  uint8_t token : 3;\n  uint8_t reserved : 1;\n  int8_t color_ctx : 4;\n} TokenExtra;\n\nint8_t GetColorCtx(const TokenExtra *t) {\n  return t-\u003ecolor_ctx;\n}\n\nuint8_t GetToken(const TokenExtra *t) {\n  return t-\u003etoken;\n}\n$ gcc -std\u003dc99 -Wall -Wextra -O3 -S -c bitfield.c",
      "revId": "b916cb17098ddfa0c19891359210b00fe547ad40",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    }
  ]
}