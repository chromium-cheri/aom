{
  "comments": [
    {
      "key": {
        "uuid": "88e1fb42_ab40d967",
        "filename": "av1/av1_common.mk",
        "patchSetId": 9
      },
      "lineNbr": 78,
      "author": {
        "id": 5435
      },
      "writtenOn": "2016-08-24T20:03:47Z",
      "side": 1,
      "message": "The benefit to using a .h extension for clpf_simd is that it\u0027s added to this list but not compiled by itself.\n\nThis build system is indeed strange, but if the file is not included somewhere here then it won\u0027t be included when rolling this into chromium or mozilla, creating additional headaches.\n\nEvery file that is used has to be in this list.",
      "revId": "be2b67a89e676840cb79b8c254b50f73c5ac86df",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a59b4a32_9b390b3a",
        "filename": "av1/av1_common.mk",
        "patchSetId": 9
      },
      "lineNbr": 78,
      "author": {
        "id": 5111
      },
      "writtenOn": "2016-08-25T13:02:27Z",
      "side": 1,
      "message": "Sounds like something else needs fixing, but I\u0027ll happily accommodate.",
      "parentUuid": "88e1fb42_ab40d967",
      "revId": "be2b67a89e676840cb79b8c254b50f73c5ac86df",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c5775ebf_b4c4203f",
        "filename": "av1/av1_common.mk",
        "patchSetId": 9
      },
      "lineNbr": 78,
      "author": {
        "id": 5435
      },
      "writtenOn": "2016-08-25T16:13:46Z",
      "side": 1,
      "message": "There have been many discussions about changing the build system in libvpx. What exists \"works\" for the multitude of platforms it supports. libaom may diverge and start it\u0027s own thing, I have no insight there. In either case, having a .c file that is not compiled on its own seems like a tricky thing.",
      "parentUuid": "a59b4a32_9b390b3a",
      "revId": "be2b67a89e676840cb79b8c254b50f73c5ac86df",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "48b54343_b682f0ae",
        "filename": "av1/common/clpf.c",
        "patchSetId": 9
      },
      "lineNbr": 33,
      "author": {
        "id": 5435
      },
      "writtenOn": "2016-08-25T00:06:03Z",
      "side": 1,
      "message": "It appears x0 and y0 are the starting coordinates of the filter. These should be added to src when calling the function:\nclpf_block(rec-\u003ey_buffer + xpos + stride_y * ypos, ...)\n\nThis reduces the number of arguments and simplifies the calculations inside clpf_block(), which makes it easier to implement and test.",
      "revId": "be2b67a89e676840cb79b8c254b50f73c5ac86df",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "858566ca_a2393e39",
        "filename": "av1/common/clpf.c",
        "patchSetId": 9
      },
      "lineNbr": 33,
      "author": {
        "id": 5111
      },
      "writtenOn": "2016-08-25T13:02:27Z",
      "side": 1,
      "message": "I disagree, because the absolute position is needed to test against the borders.",
      "parentUuid": "48b54343_b682f0ae",
      "revId": "be2b67a89e676840cb79b8c254b50f73c5ac86df",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c5775ebf_74f8c878",
        "filename": "av1/common/clpf.c",
        "patchSetId": 9
      },
      "lineNbr": 33,
      "author": {
        "id": 5435
      },
      "writtenOn": "2016-08-25T16:13:46Z",
      "side": 1,
      "message": "Having the low level function need to know about the borders seems like part of the problem to me. It introduces calculations at the point where you really don\u0027t want them.",
      "parentUuid": "858566ca_a2393e39",
      "revId": "be2b67a89e676840cb79b8c254b50f73c5ac86df",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "48b54343_16c2dc03",
        "filename": "av1/common/clpf.c",
        "patchSetId": 9
      },
      "lineNbr": 38,
      "author": {
        "id": 5435
      },
      "writtenOn": "2016-08-25T00:06:03Z",
      "side": 1,
      "message": "Looking at your design document:\n\"If an input pixel is outside the frame border, the nearest pixel inside the frame is used.\"\n\nThe frame should have a border to allow over-reading. Is that not an option in this case? It would make a massive improvement to the number of arguments and the number of branches inside the function.",
      "revId": "be2b67a89e676840cb79b8c254b50f73c5ac86df",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "858566ca_c236c248",
        "filename": "av1/common/clpf.c",
        "patchSetId": 9
      },
      "lineNbr": 38,
      "author": {
        "id": 5111
      },
      "writtenOn": "2016-08-25T13:02:27Z",
      "side": 1,
      "message": "That is not assumed, since the filter is applied to the reconstructed frame and not on the reference frame.  I wouldn\u0027t expect the encoder or decoder to add the padding until the frame is actually used as a reference frame.\n\nMoreover, we likely don\u0027t want to filter across some tile boundaries.  I think it\u0027s still under debate whether this only applies to vertical boundaries or horizontal as well.  CLPF will have to be updated to support whatever is agreed upon concerning tiles, and the current way borders are handled will require the least changes.  I expect even less that tiles will have borders to allow over-reading.\n\nIn the SIMD code the border testing is efficiently handled through shuffle instructions.",
      "parentUuid": "48b54343_16c2dc03",
      "revId": "be2b67a89e676840cb79b8c254b50f73c5ac86df",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c5775ebf_f415b89a",
        "filename": "av1/common/clpf.c",
        "patchSetId": 9
      },
      "lineNbr": 38,
      "author": {
        "id": 5435
      },
      "writtenOn": "2016-08-25T16:13:46Z",
      "side": 1,
      "message": "Well the filter isn\u0027t being applied across boundaries - it\u0027s just using reference values across them.\n\nIn practice at least A and F are effectively discarded at their respective borders - given X at 1,0:\n\nA \u003d max(0, y-1) \u003d 0  * stride\nso A \u003d X\nA-X \u003d 0\n*4 \u003d 0\nclamped (-s, s) \u003d 0\n\nB, C, D, and E are partially discarded\ngiven X at (2, 0)\nB \u003d C \u003d X and all values are discarded\nat (1, 0)\nB \u003d C\nclamp(C - X, -b, b) + 3 * clamp(C - X, -b, b)\nthat gets weird since it just does a *4 but preserves the sign",
      "parentUuid": "858566ca_c236c248",
      "revId": "be2b67a89e676840cb79b8c254b50f73c5ac86df",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "255bda40_87254658",
        "filename": "av1/common/clpf.c",
        "patchSetId": 9
      },
      "lineNbr": 38,
      "author": {
        "id": 5111
      },
      "writtenOn": "2016-08-25T20:35:15Z",
      "side": 1,
      "message": "The question is whether a tile should in any way depend on another tile.\n\nThe filter\u0027s job is to make pixels more like their neighbours if the neighbours mostly pull in the same direction.  It\u0027s a non-linear filter so perhaps weird by design.  At the borders and in particular the corners there are fewer neighbours.  I don\u0027t quite get what you mean by preserving the sign.",
      "parentUuid": "c5775ebf_f415b89a",
      "revId": "be2b67a89e676840cb79b8c254b50f73c5ac86df",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c5b2fe10_c5bf50bf",
        "filename": "av1/common/clpf.c",
        "patchSetId": 9
      },
      "lineNbr": 38,
      "author": {
        "id": 5435
      },
      "writtenOn": "2016-08-26T23:24:04Z",
      "side": 1,
      "message": "I was thinking of power functions not multiplication. Sorry about the sign nonsense.\n\nI think there is a way to discard some calculations instead of shuffling/conditional loads.",
      "parentUuid": "255bda40_87254658",
      "revId": "be2b67a89e676840cb79b8c254b50f73c5ac86df",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "88e1fb42_2b668923",
        "filename": "av1/common/clpf_neon.c",
        "patchSetId": 9
      },
      "lineNbr": 13,
      "author": {
        "id": 5435
      },
      "writtenOn": "2016-08-24T20:03:47Z",
      "side": 1,
      "message": "The sse4 example is sufficient. If it goes to production it might be worth adding neon, sse2, etc but at the moment having an example is enough.",
      "revId": "be2b67a89e676840cb79b8c254b50f73c5ac86df",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "255bda40_e79e42fe",
        "filename": "av1/common/clpf_neon.c",
        "patchSetId": 9
      },
      "lineNbr": 13,
      "author": {
        "id": 5111
      },
      "writtenOn": "2016-08-25T13:02:27Z",
      "side": 1,
      "message": "But the rest comes for free and I though an important point of an example was to show how to instantiate single SIMD functions for several architectures.",
      "parentUuid": "88e1fb42_2b668923",
      "revId": "be2b67a89e676840cb79b8c254b50f73c5ac86df",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c5775ebf_b40f4089",
        "filename": "av1/common/clpf_neon.c",
        "patchSetId": 9
      },
      "lineNbr": 13,
      "author": {
        "id": 5435
      },
      "writtenOn": "2016-08-25T16:13:46Z",
      "side": 1,
      "message": "Sure, but you don\u0027t necessarily want people cluttering up the tree and build times with extraneous files. sse4 and neon?",
      "parentUuid": "255bda40_e79e42fe",
      "revId": "be2b67a89e676840cb79b8c254b50f73c5ac86df",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "255bda40_870c26ee",
        "filename": "av1/common/clpf_neon.c",
        "patchSetId": 9
      },
      "lineNbr": 13,
      "author": {
        "id": 5111
      },
      "writtenOn": "2016-08-25T20:35:15Z",
      "side": 1,
      "message": "People decide that themselves with --enable/disable-sse3 etc - isn\u0027t such things what configure is for?\n\nAnyway, I compiled the entire codec 80 times and then 80 times again with your suggestion on my 2 (3?) year old computer.  Sure, the average compile time went down, from 18.111\" to 17.959\", a 0.8% decrease, a 152 ms extra wait.  This is well below my \"don\u0027t care\" threshold.\n\nThe clutter is 2845 bytes, most of which is the copyright notice, an 0.006% increase in code size.",
      "parentUuid": "c5775ebf_b40f4089",
      "revId": "be2b67a89e676840cb79b8c254b50f73c5ac86df",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c5b2fe10_05e4180f",
        "filename": "av1/common/clpf_neon.c",
        "patchSetId": 9
      },
      "lineNbr": 13,
      "author": {
        "id": 5435
      },
      "writtenOn": "2016-08-26T23:24:04Z",
      "side": 1,
      "message": "--disable-ssse3 also disables sse4. It used to only disable ssse3 but then people started sharing code between files and it got tricky.\n\nSure, adding a single implementation isn\u0027t a big deal. I\u0027m concerned about people following suit when they add other optimizations. There is also binary size and test run time to consider.",
      "parentUuid": "255bda40_870c26ee",
      "revId": "be2b67a89e676840cb79b8c254b50f73c5ac86df",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "48b54343_f6df5863",
        "filename": "av1/common/clpf_simd.c",
        "patchSetId": 9
      },
      "lineNbr": 28,
      "author": {
        "id": 5435
      },
      "writtenOn": "2016-08-25T00:06:03Z",
      "side": 1,
      "message": "This appears to load an 8 bit value, and add 128. What happens if the value is already over 128? Should it expand to 16 to prevent overflow?",
      "revId": "be2b67a89e676840cb79b8c254b50f73c5ac86df",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e59542fc_bdcabf17",
        "filename": "av1/common/clpf_simd.c",
        "patchSetId": 9
      },
      "lineNbr": 28,
      "author": {
        "id": 5111
      },
      "writtenOn": "2016-08-25T13:02:27Z",
      "side": 1,
      "message": "I\u0027m taking advantage of the nature of two-complement arithmetics and intentionally shifting the range from 0-255 to -128-127, so that I can use signed saturated subtraction later and avoid having to expand to 16 bit.",
      "parentUuid": "48b54343_f6df5863",
      "revId": "be2b67a89e676840cb79b8c254b50f73c5ac86df",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c5775ebf_946b241a",
        "filename": "av1/common/clpf_simd.c",
        "patchSetId": 9
      },
      "lineNbr": 28,
      "author": {
        "id": 5435
      },
      "writtenOn": "2016-08-25T16:13:46Z",
      "side": 1,
      "message": "Is there any distinction to the simd framework between signed and unsigned values? I feel like you\u0027re relying on undefined overflow behavior here.",
      "parentUuid": "e59542fc_bdcabf17",
      "revId": "be2b67a89e676840cb79b8c254b50f73c5ac86df",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "255bda40_67b6d2f1",
        "filename": "av1/common/clpf_simd.c",
        "patchSetId": 9
      },
      "lineNbr": 28,
      "author": {
        "id": 5111
      },
      "writtenOn": "2016-08-25T21:00:34Z",
      "side": 1,
      "message": "I\u0027ll get back to this tomorrow.",
      "parentUuid": "c5775ebf_946b241a",
      "revId": "be2b67a89e676840cb79b8c254b50f73c5ac86df",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e5ef02c1_8db121dc",
        "filename": "av1/common/clpf_simd.c",
        "patchSetId": 9
      },
      "lineNbr": 28,
      "author": {
        "id": 5111
      },
      "writtenOn": "2016-08-26T07:47:05Z",
      "side": 1,
      "message": "The simd framework makes a distinction, but only when it matters.  _s8, _s16, _s32 for signed, _u8, _u16, _u32 for unsigned, and _8, _16, _32 when it doesn\u0027t matter.\n\nFor regular two\u0027s complement add and sub the sign doesn\u0027t matter and the overflow behaviour is always defined.  Two\u0027s complement subtraction guarantees for any i, j and k: i - j \u003d\u003d (i+k) - (j+k).  So overflow doesn\u0027t matter, nothing is undefined and nothing gets lost by adding 128.\n\nThe frame content is uint8_t, and in order to get the subtractions right, we need 9 bits.  The difference between any unsigned numbers between 0 to 255 is a signed 9 bit value which can be anything from -255 to +255.  But we would like to do 16 pixels at a time using 128 bit vectors.  So I add 128 (equivalent to subtracting 128) to all the values, so I get values between -128 and 127.  Then the trick is to do a signed _saturated_ subtraction which takes precisely [-128, 127] input and clamps the result to [-128, 127], and this is fine since the maximum strength is +/- 4.",
      "parentUuid": "255bda40_67b6d2f1",
      "revId": "be2b67a89e676840cb79b8c254b50f73c5ac86df",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "88e1fb42_eb6661bc",
        "filename": "av1/common/clpf_simd.c",
        "patchSetId": 9
      },
      "lineNbr": 31,
      "author": {
        "id": 5435
      },
      "writtenOn": "2016-08-24T20:03:47Z",
      "side": 1,
      "message": "I\u0027m not familiar with this usage of !! and having difficulty understanding this. What are the possible values of x0?\n\nCasting to uint32_t here seems more problematic than above because you are subtracting 2 (or 0, I think?).\n\nSee this issue in clang:\nhttps://bugs.chromium.org/p/webm/issues/detail?id\u003d892\nhttps://llvm.org/bugs/show_bug.cgi?id\u003d24421",
      "revId": "be2b67a89e676840cb79b8c254b50f73c5ac86df",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "48b54343_f66118a7",
        "filename": "av1/common/clpf_simd.c",
        "patchSetId": 9
      },
      "lineNbr": 31,
      "author": {
        "id": 5435
      },
      "writtenOn": "2016-08-25T00:06:03Z",
      "side": 1,
      "message": "Suppose x0 \u003d 1 (please assert() somewhere if this is not possible). This would load invalid data.\n\nSuppose x0 \u003d 0. This will load incorrect data for all X except the column next to the edge. The \u0027B\u0027 value for 1,[0-3] will be \u0027X\u0027 where it should be \u0027C\u0027",
      "parentUuid": "88e1fb42_eb6661bc",
      "revId": "be2b67a89e676840cb79b8c254b50f73c5ac86df",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "255bda40_e7676220",
        "filename": "av1/common/clpf_simd.c",
        "patchSetId": 9
      },
      "lineNbr": 31,
      "author": {
        "id": 5111
      },
      "writtenOn": "2016-08-25T13:02:27Z",
      "side": 1,
      "message": "See below.",
      "parentUuid": "48b54343_f66118a7",
      "revId": "be2b67a89e676840cb79b8c254b50f73c5ac86df",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "858566ca_025fca7a",
        "filename": "av1/common/clpf_simd.c",
        "patchSetId": 9
      },
      "lineNbr": 31,
      "author": {
        "id": 5111
      },
      "writtenOn": "2016-08-25T13:02:27Z",
      "side": 1,
      "message": "!!x is more convenient way to express (x ? 1 : 0) or (bool)x in C99, and possibly a safe-guard against compilers stupid enough to generate a branch for the expression.\n\nThe 32 bit load is intended to be unaligned.  It should be replaced with u32_load_unaligned(), which has a proper implementation on arm for unaligned access.",
      "parentUuid": "88e1fb42_eb6661bc",
      "revId": "be2b67a89e676840cb79b8c254b50f73c5ac86df",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c5775ebf_14515468",
        "filename": "av1/common/clpf_simd.c",
        "patchSetId": 9
      },
      "lineNbr": 31,
      "author": {
        "id": 5435
      },
      "writtenOn": "2016-08-25T16:13:46Z",
      "side": 1,
      "message": "The framework also had a 32 bit aligned load. Why not use that instead of casting to uint32?",
      "parentUuid": "858566ca_025fca7a",
      "revId": "be2b67a89e676840cb79b8c254b50f73c5ac86df",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "858566ca_02034ac1",
        "filename": "av1/common/clpf_simd.c",
        "patchSetId": 9
      },
      "lineNbr": 31,
      "author": {
        "id": 5111
      },
      "writtenOn": "2016-08-25T20:35:15Z",
      "side": 1,
      "message": "I agree.  But on second thought I think we can just scrap the 4x4 function and fall back to the C implementation instead, because it will only be used rarely in rare cases (chroma 420, along the right border, if width is not multiple of 16).",
      "parentUuid": "c5775ebf_14515468",
      "revId": "be2b67a89e676840cb79b8c254b50f73c5ac86df",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "48b54343_b612f00c",
        "filename": "av1/common/clpf_simd.c",
        "patchSetId": 9
      },
      "lineNbr": 52,
      "author": {
        "id": 5435
      },
      "writtenOn": "2016-08-25T00:06:03Z",
      "side": 1,
      "message": "Ah, does this duplicate the first 2 values and shuffle the rest to the right?",
      "revId": "be2b67a89e676840cb79b8c254b50f73c5ac86df",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0554160d_e6ecfe8d",
        "filename": "av1/common/clpf_simd.c",
        "patchSetId": 9
      },
      "lineNbr": 52,
      "author": {
        "id": 5111
      },
      "writtenOn": "2016-08-25T13:02:27Z",
      "side": 1,
      "message": "Yes, correcting the invalid load above.",
      "parentUuid": "48b54343_b612f00c",
      "revId": "be2b67a89e676840cb79b8c254b50f73c5ac86df",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "48b54343_995a7f85",
        "filename": "av1/common/clpf_simd.c",
        "patchSetId": 9
      },
      "lineNbr": 75,
      "author": {
        "id": 5435
      },
      "writtenOn": "2016-08-25T00:06:03Z",
      "side": 1,
      "message": "Since A and F are both:\nclip(A-F, -s, s) * 4 (and therefore positive), you can do absolute difference and just max (skip min) ... except the simd framework only appears to do so for 16 bits?",
      "revId": "be2b67a89e676840cb79b8c254b50f73c5ac86df",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0554160d_a6e606aa",
        "filename": "av1/common/clpf_simd.c",
        "patchSetId": 9
      },
      "lineNbr": 75,
      "author": {
        "id": 5111
      },
      "writtenOn": "2016-08-25T13:02:27Z",
      "side": 1,
      "message": "I don\u0027t see what you mean here.",
      "parentUuid": "48b54343_995a7f85",
      "revId": "be2b67a89e676840cb79b8c254b50f73c5ac86df",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c5775ebf_b4418097",
        "filename": "av1/common/clpf_simd.c",
        "patchSetId": 9
      },
      "lineNbr": 75,
      "author": {
        "id": 5435
      },
      "writtenOn": "2016-08-25T16:13:46Z",
      "side": 1,
      "message": "min(abd(A, F), s) * 4 is equivalent because whether A-F is positive or negative, * 4 makes it positive. Then you only need to compare it to s, not -s",
      "parentUuid": "0554160d_a6e606aa",
      "revId": "be2b67a89e676840cb79b8c254b50f73c5ac86df",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "255bda40_87d78618",
        "filename": "av1/common/clpf_simd.c",
        "patchSetId": 9
      },
      "lineNbr": 75,
      "author": {
        "id": 5111
      },
      "writtenOn": "2016-08-25T21:00:34Z",
      "side": 1,
      "message": "Negative * 4 -\u003e negative\nPositive * 4 -\u003e positive",
      "parentUuid": "c5775ebf_b4418097",
      "revId": "be2b67a89e676840cb79b8c254b50f73c5ac86df",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c5b2fe10_059f785f",
        "filename": "av1/common/clpf_simd.c",
        "patchSetId": 9
      },
      "lineNbr": 75,
      "author": {
        "id": 5435
      },
      "writtenOn": "2016-08-26T23:24:04Z",
      "side": 1,
      "message": "Of course. Sorry about that.",
      "parentUuid": "255bda40_87d78618",
      "revId": "be2b67a89e676840cb79b8c254b50f73c5ac86df",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "48b54343_56474479",
        "filename": "av1/common/clpf_simd.c",
        "patchSetId": 9
      },
      "lineNbr": 264,
      "author": {
        "id": 5435
      },
      "writtenOn": "2016-08-25T00:06:03Z",
      "side": 1,
      "message": "What are the possible sizex/sizey values? They should be assert()\u0027d. Ideally in the C version.\n\nDoes it matter than chroma is 4x4 or 4x8 and luma is 8x8? Would be more useful to indicate the size of the block being filtered in the comment than whether it is chroma or luma.",
      "revId": "be2b67a89e676840cb79b8c254b50f73c5ac86df",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "45560e16_2878abee",
        "filename": "av1/common/clpf_simd.c",
        "patchSetId": 9
      },
      "lineNbr": 264,
      "author": {
        "id": 5111
      },
      "writtenOn": "2016-08-25T13:02:27Z",
      "side": 1,
      "message": "Currently this is not an issue since the filter is only applied on luma, but I don\u0027t wish to burn the chroma bridge quite yet, so the code is there.  So right now sizex and sizey can only be 8, but chroma filtering is enabled, the values can be 4 or 8 (independently) if the frame/tile width or height is not a multiple of 8.\n\nThe C version supports any sizes, but 8x8 is hard coded for now.\n\nI\u0027ll fix the comments, and also add a TODO about non-8x8 which still needs to be decided on.",
      "parentUuid": "48b54343_56474479",
      "revId": "be2b67a89e676840cb79b8c254b50f73c5ac86df",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    }
  ]
}