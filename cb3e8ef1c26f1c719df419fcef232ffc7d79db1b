{
  "comments": [
    {
      "key": {
        "uuid": "58b4e430_26dcc983",
        "filename": "av1/av1_dx_iface.c",
        "patchSetId": 3
      },
      "lineNbr": 169,
      "author": {
        "id": 9545
      },
      "writtenOn": "2019-03-19T16:51:45Z",
      "side": 1,
      "message": "This checks the following requirement in Section 6.4.3 (Timing info semantics) of the spec:\n\n  It is a requirement of bitstream conformance that the value of\n  num_ticks_per_picture_minus_1 shall be in the range of 0 to\n  (1 \u003c\u003c 32) − 2, inclusive.\n\nThe main decoder code (the av1_read_timing_info_header() function in av1/decoder/decodeframe.c) checks the requirement in the same way:\n\n    cm-\u003etiming_info.num_ticks_per_picture \u003d\n        aom_rb_read_uvlc(rb) + 1;  // ticks per picture\n    if (cm-\u003etiming_info.num_ticks_per_picture \u003d\u003d 0) {\n      aom_internal_error(\n          \u0026cm-\u003eerror, AOM_CODEC_UNSUP_BITSTREAM,\n          \"num_ticks_per_picture_minus_1 cannot be (1 \u003c\u003c 32) − 1.\");\n    }\n\nIf you prefer to check the requirement before the addition of 1, we can do it as follows:\n\n    const uint32_t num_ticks_per_picture_minus_1 \u003d aom_rb_read_uvlc(rb);\n    if (num_ticks_per_picture_minus_1 \u003d\u003d UINT32_MAX - 1) return AOM_CODEC_UNSUP_BITSTREAM;",
      "range": {
        "startLine": 165,
        "startChar": 0,
        "endLine": 169,
        "endChar": 5
      },
      "revId": "cb3e8ef1c26f1c719df419fcef232ffc7d79db1b",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "58cbf6b5_d11c69a4",
        "filename": "av1/av1_dx_iface.c",
        "patchSetId": 3
      },
      "lineNbr": 169,
      "author": {
        "id": 9545
      },
      "writtenOn": "2019-03-19T16:56:15Z",
      "side": 1,
      "message": "I found an error in my alternative fix. The second line should read:\n\n    if (num_ticks_per_picture_minus_1 \u003d\u003d UINT32_MAX) return AOM_CODEC_UNSUP_BITSTREAM;",
      "parentUuid": "58b4e430_26dcc983",
      "range": {
        "startLine": 165,
        "startChar": 0,
        "endLine": 169,
        "endChar": 5
      },
      "revId": "cb3e8ef1c26f1c719df419fcef232ffc7d79db1b",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "97188e78_9e61f913",
        "filename": "av1/av1_dx_iface.c",
        "patchSetId": 3
      },
      "lineNbr": 169,
      "author": {
        "id": 5187
      },
      "writtenOn": "2019-03-19T16:59:16Z",
      "side": 1,
      "message": "Sorry I missed this part. Your patch may trigger integer overflow if aom_rb_read_uvlc(rb) returns uint32_max. So I propose this:\n\nconst uint32_t val \u003d aom_rb_read_uvlc(rb);\nconst uint32_t num_ticks_per_picture \u003d\n    (val \u003e UINT32_MAX - 2) ? 0 : val + 1;\nif (num_ticks_per_picture \u003d\u003d 0) return AOM_CODEC_UNSUP_BITSTREAM;",
      "parentUuid": "58b4e430_26dcc983",
      "range": {
        "startLine": 165,
        "startChar": 0,
        "endLine": 169,
        "endChar": 5
      },
      "revId": "cb3e8ef1c26f1c719df419fcef232ffc7d79db1b",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    }
  ]
}