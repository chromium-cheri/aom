{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "326eefc3_37946b50",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 9611
      },
      "writtenOn": "2022-03-09T13:56:10Z",
      "side": 1,
      "message": "Hi Yunqing, \n\nThe model_skip_for_sb_y_large() is called for block sizes \u003e\u003d BLOCK_32X32 and decides if the mode can be coded as skippable using variance, sse and model_rd. Currently, the function block_variance() (from model_skip_for_sb_y_large()) is called to calculate sum, sse, variance at 8x8 level and the same values are used to compute variance at 16x16/32x32 level based on the tx_size selected.\n\nWe have introduced an AVX2 intrinsic function to process four 8x8 sub-blocks (i.e. one 8x32 block) of a given block simultaneously. This CL adds equivalent SSE2 intrinsic to support the AVX2 implementation. The patch also has relevant unit test changes.\n \nPlease review the patch\n\nThanks \u0026 Regards,\nVenkata\n",
      "revId": "23f35459fd40dae044ac0a983b74c82163773c70",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "06d8edc9_34015a75",
        "filename": "aom_dsp/variance.c",
        "patchSetId": 1
      },
      "lineNbr": 212,
      "author": {
        "id": 5185
      },
      "writtenOn": "2022-03-09T16:45:52Z",
      "side": 1,
      "message": "Is this for 8x32 block? If yes, can it be called aom_get8x32var directly?",
      "range": {
        "startLine": 212,
        "startChar": 5,
        "endLine": 212,
        "endChar": 23
      },
      "revId": "23f35459fd40dae044ac0a983b74c82163773c70",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    }
  ]
}