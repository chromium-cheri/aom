{
  "comments": [
    {
      "key": {
        "uuid": "a6af32df_425ac869",
        "filename": "aomenc.c",
        "patchSetId": 6
      },
      "lineNbr": 55,
      "author": {
        "id": 5020
      },
      "writtenOn": "2017-05-09T15:43:14Z",
      "side": 1,
      "message": "this should be stored in a config, like the first pass file if it\u0027s meant to stick around",
      "revId": "bc4ba8cedf985c2cf090d5b5d38404ce9c3e32e8",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c2417bd3_b9aedd38",
        "filename": "aomenc.c",
        "patchSetId": 6
      },
      "lineNbr": 55,
      "author": {
        "id": 5326
      },
      "writtenOn": "2017-05-09T16:49:38Z",
      "side": 1,
      "message": "I initially wanted to add this file to be similar as the output bitstream file in the config structure. the problem is that there is no interface to pass this file name into the \"encoder\" itself so encoder can access and write into this file. also, there is no interface to get the reconstructed frame out of the \"encoder\" so aomenc.c can write that into this file. so eventually I ended up using  a global variable to pass the file name into the underline encoder itself to avoid big interface changes. Do you have any suggestions on how I can work around this limitation on Linux?",
      "parentUuid": "a6af32df_425ac869",
      "revId": "bc4ba8cedf985c2cf090d5b5d38404ce9c3e32e8",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0d58037d_588732be",
        "filename": "aomenc.c",
        "patchSetId": 6
      },
      "lineNbr": 55,
      "author": {
        "id": 5020
      },
      "writtenOn": "2017-05-10T04:03:59Z",
      "side": 1,
      "message": "\u003e I initially wanted to add this file to be similar as the output bitstream file in the config structure. the problem is that there is no interface to pass this file name into the \"encoder\" itself so encoder can access and write into this file. also, there is no interface to get the reconstructed frame out of the \"encoder\" so aomenc.c can write that into this file. so eventually I ended up using  a global variable to pass the file name into the underline encoder itself to avoid big interface changes. Do you have any suggestions on how I can work around this limitation on Linux?\n\nusing  a global to influence the encode is not a long term solution. Without looking, I don\u0027t see why extending the configuration to support this is a problem, again we do it for the first pass file.",
      "parentUuid": "c2417bd3_b9aedd38",
      "revId": "bc4ba8cedf985c2cf090d5b5d38404ce9c3e32e8",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a288b00_3fccd725",
        "filename": "aomenc.c",
        "patchSetId": 6
      },
      "lineNbr": 55,
      "author": {
        "id": 5326
      },
      "writtenOn": "2017-05-10T17:03:09Z",
      "side": 1,
      "message": "Hi, James\n\nit is a little different for the first pass stat file. if you look at the code, all file open and handling for the stat file are done in aomenc.c (higher level). after processing a frame for the first pass, aomenc.c calls get_cx_data to get the stats buffer out of the underline encoder, and then write into the file. so the underline encoder doesn\u0027t see the file name or the file handler. for recon file, there is no interface to get the recon surface out of the underline encoder, so I have to pass either the file name or the file handler into the underline encoder. to avoid the interface change, I used a global variable. another solution is to just open the file in the underline encoder using a fixed temporary name, like the original code does. the problem is multiple encoding sessions will access the same file, which cause conflict.",
      "parentUuid": "0d58037d_588732be",
      "revId": "bc4ba8cedf985c2cf090d5b5d38404ce9c3e32e8",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6a9b5262_ab7b7ffc",
        "filename": "aomenc.c",
        "patchSetId": 6
      },
      "lineNbr": 55,
      "author": {
        "id": 5020
      },
      "writtenOn": "2017-05-10T17:35:10Z",
      "side": 1,
      "message": "\u003e Hi, James\n\u003e \n\u003e it is a little different for the first pass stat file. if you look at the code, all file open and handling for the stat file are done in aomenc.c (higher level). after processing a frame for the first pass, aomenc.c calls get_cx_data to get the stats buffer out of the underline encoder, and then write into the file. so the underline encoder doesn\u0027t see the file name or the file handler. for recon file, there is no interface to get the recon surface out of the underline encoder,\n\nSounds like vpx_codec_get_preview_frame\n\n\u003e so I have to pass either the file name or the file handler into the underline encoder. to avoid the interface change, I used a global variable. another solution is to just open the file in the underline encoder using a fixed temporary name, like the original code does. the problem is multiple encoding sessions will access the same file, which cause conflict.\n\nIt\u0027s just code so you can always forward this down if you needed to or add a new control / function to get at the data you\u0027re after.",
      "parentUuid": "3a288b00_3fccd725",
      "revId": "bc4ba8cedf985c2cf090d5b5d38404ce9c3e32e8",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "dbbba936_62e060d0",
        "filename": "aomenc.c",
        "patchSetId": 6
      },
      "lineNbr": 55,
      "author": {
        "id": 5020
      },
      "writtenOn": "2017-05-10T17:35:45Z",
      "side": 1,
      "message": "\u003e \u003e Hi, James\n\u003e \u003e \n\u003e \u003e it is a little different for the first pass stat file. if you look at the code, all file open and handling for the stat file are done in aomenc.c (higher level). after processing a frame for the first pass, aomenc.c calls get_cx_data to get the stats buffer out of the underline encoder, and then write into the file. so the underline encoder doesn\u0027t see the file name or the file handler. for recon file, there is no interface to get the recon surface out of the underline encoder,\n\u003e \n\u003e Sounds like vpx_codec_get_preview_frame\n\u003e \n\naom_ that is\n\n\u003e \u003e so I have to pass either the file name or the file handler into the underline encoder. to avoid the interface change, I used a global variable. another solution is to just open the file in the underline encoder using a fixed temporary name, like the original code does. the problem is multiple encoding sessions will access the same file, which cause conflict.\n\u003e \n\u003e It\u0027s just code so you can always forward this down if you needed to or add a new control / function to get at the data you\u0027re after.",
      "parentUuid": "6a9b5262_ab7b7ffc",
      "revId": "bc4ba8cedf985c2cf090d5b5d38404ce9c3e32e8",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c7a04e94_26d9a008",
        "filename": "aomenc.c",
        "patchSetId": 6
      },
      "lineNbr": 55,
      "author": {
        "id": 5326
      },
      "writtenOn": "2017-05-10T20:58:20Z",
      "side": 1,
      "message": "James\n\nI just tried the your idea to use aom_codec_get_preview_frame to get the recon buffer after calling aom_codec_encode(). it works for single pass mode, since aom_codec_encode will always encode one frame. However, in two pass mode, for the second pass, aom_codec_encode will encode the whole sequence internally, so I can only get the last frame out in two pass mode if I call aom_codec_get_preview_frame after aom_codec_encode.",
      "parentUuid": "dbbba936_62e060d0",
      "revId": "bc4ba8cedf985c2cf090d5b5d38404ce9c3e32e8",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fadde776_47c7c3e2",
        "filename": "aomenc.c",
        "patchSetId": 6
      },
      "lineNbr": 761,
      "author": {
        "id": 6000
      },
      "writtenOn": "2017-05-10T05:53:50Z",
      "side": 1,
      "message": "s/strlen(arg.val)/sizeof(reconfile_name)/\nright?",
      "revId": "bc4ba8cedf985c2cf090d5b5d38404ce9c3e32e8",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b5dc50f6_a727ce2c",
        "filename": "aomenc.c",
        "patchSetId": 6
      },
      "lineNbr": 761,
      "author": {
        "id": 5326
      },
      "writtenOn": "2017-05-10T17:03:09Z",
      "side": 1,
      "message": "I allocated 512 bytes for reconfile_name. I agree it may not be the safest way.",
      "parentUuid": "fadde776_47c7c3e2",
      "revId": "bc4ba8cedf985c2cf090d5b5d38404ce9c3e32e8",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": true
    }
  ]
}