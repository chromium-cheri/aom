{
  "comments": [
    {
      "key": {
        "uuid": "a6af32df_425ac869",
        "filename": "aomenc.c",
        "patchSetId": 6
      },
      "lineNbr": 55,
      "author": {
        "id": 5020
      },
      "writtenOn": "2017-05-09T15:43:14Z",
      "side": 1,
      "message": "this should be stored in a config, like the first pass file if it\u0027s meant to stick around",
      "revId": "bc4ba8cedf985c2cf090d5b5d38404ce9c3e32e8",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c2417bd3_b9aedd38",
        "filename": "aomenc.c",
        "patchSetId": 6
      },
      "lineNbr": 55,
      "author": {
        "id": 5326
      },
      "writtenOn": "2017-05-09T16:49:38Z",
      "side": 1,
      "message": "I initially wanted to add this file to be similar as the output bitstream file in the config structure. the problem is that there is no interface to pass this file name into the \"encoder\" itself so encoder can access and write into this file. also, there is no interface to get the reconstructed frame out of the \"encoder\" so aomenc.c can write that into this file. so eventually I ended up using  a global variable to pass the file name into the underline encoder itself to avoid big interface changes. Do you have any suggestions on how I can work around this limitation on Linux?",
      "parentUuid": "a6af32df_425ac869",
      "revId": "bc4ba8cedf985c2cf090d5b5d38404ce9c3e32e8",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0d58037d_588732be",
        "filename": "aomenc.c",
        "patchSetId": 6
      },
      "lineNbr": 55,
      "author": {
        "id": 5020
      },
      "writtenOn": "2017-05-10T04:03:59Z",
      "side": 1,
      "message": "\u003e I initially wanted to add this file to be similar as the output bitstream file in the config structure. the problem is that there is no interface to pass this file name into the \"encoder\" itself so encoder can access and write into this file. also, there is no interface to get the reconstructed frame out of the \"encoder\" so aomenc.c can write that into this file. so eventually I ended up using  a global variable to pass the file name into the underline encoder itself to avoid big interface changes. Do you have any suggestions on how I can work around this limitation on Linux?\n\nusing  a global to influence the encode is not a long term solution. Without looking, I don\u0027t see why extending the configuration to support this is a problem, again we do it for the first pass file.",
      "parentUuid": "c2417bd3_b9aedd38",
      "revId": "bc4ba8cedf985c2cf090d5b5d38404ce9c3e32e8",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a288b00_3fccd725",
        "filename": "aomenc.c",
        "patchSetId": 6
      },
      "lineNbr": 55,
      "author": {
        "id": 5326
      },
      "writtenOn": "2017-05-10T17:03:09Z",
      "side": 1,
      "message": "Hi, James\n\nit is a little different for the first pass stat file. if you look at the code, all file open and handling for the stat file are done in aomenc.c (higher level). after processing a frame for the first pass, aomenc.c calls get_cx_data to get the stats buffer out of the underline encoder, and then write into the file. so the underline encoder doesn\u0027t see the file name or the file handler. for recon file, there is no interface to get the recon surface out of the underline encoder, so I have to pass either the file name or the file handler into the underline encoder. to avoid the interface change, I used a global variable. another solution is to just open the file in the underline encoder using a fixed temporary name, like the original code does. the problem is multiple encoding sessions will access the same file, which cause conflict.",
      "parentUuid": "0d58037d_588732be",
      "revId": "bc4ba8cedf985c2cf090d5b5d38404ce9c3e32e8",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fadde776_47c7c3e2",
        "filename": "aomenc.c",
        "patchSetId": 6
      },
      "lineNbr": 761,
      "author": {
        "id": 6000
      },
      "writtenOn": "2017-05-10T05:53:50Z",
      "side": 1,
      "message": "s/strlen(arg.val)/sizeof(reconfile_name)/\nright?",
      "revId": "bc4ba8cedf985c2cf090d5b5d38404ce9c3e32e8",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b5dc50f6_a727ce2c",
        "filename": "aomenc.c",
        "patchSetId": 6
      },
      "lineNbr": 761,
      "author": {
        "id": 5326
      },
      "writtenOn": "2017-05-10T17:03:09Z",
      "side": 1,
      "message": "I allocated 512 bytes for reconfile_name. I agree it may not be the safest way.",
      "parentUuid": "fadde776_47c7c3e2",
      "revId": "bc4ba8cedf985c2cf090d5b5d38404ce9c3e32e8",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": true
    }
  ]
}