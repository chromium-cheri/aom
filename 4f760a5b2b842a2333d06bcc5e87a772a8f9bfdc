{
  "comments": [
    {
      "key": {
        "uuid": "94f8cdf5_3c08d779",
        "filename": "obudec.c",
        "patchSetId": 1
      },
      "lineNbr": 41,
      "author": {
        "id": 9545
      },
      "writtenOn": "2018-04-30T23:12:44Z",
      "side": 1,
      "message": "This was added in https://aomedia-review.googlesource.com/c/aom/+/52822. I don\u0027t understand this change. It seems that reaching EOF when we expect a leb128 should be an error, i.e., we should return -1 in this case.",
      "range": {
        "startLine": 38,
        "startChar": 0,
        "endLine": 41,
        "endChar": 5
      },
      "revId": "4f760a5b2b842a2333d06bcc5e87a772a8f9bfdc",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4b77f4d1_c800ebb6",
        "filename": "obudec.c",
        "patchSetId": 1
      },
      "lineNbr": 41,
      "author": {
        "id": 9545
      },
      "writtenOn": "2018-04-30T23:22:05Z",
      "side": 1,
      "message": "At a minimum, we should return 0 here only if len \u003d\u003d 0 (i.e., we didn\u0027t read any bytes into value_buffer).",
      "parentUuid": "94f8cdf5_3c08d779",
      "range": {
        "startLine": 38,
        "startChar": 0,
        "endLine": 41,
        "endChar": 5
      },
      "revId": "4f760a5b2b842a2333d06bcc5e87a772a8f9bfdc",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bb648b2e_20faaef2",
        "filename": "obudec.c",
        "patchSetId": 1
      },
      "lineNbr": 41,
      "author": {
        "id": 5215
      },
      "writtenOn": "2018-04-30T23:58:34Z",
      "side": 1,
      "message": "In a valid section 5 and annex B streams this call is the first place where we run out of data at the end of a file. The calling code interprets length 0 w/a return value of 0 as end of input. Encountering the end of the file is not an error.",
      "parentUuid": "4b77f4d1_c800ebb6",
      "range": {
        "startLine": 38,
        "startChar": 0,
        "endLine": 41,
        "endChar": 5
      },
      "revId": "4f760a5b2b842a2333d06bcc5e87a772a8f9bfdc",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8825fb4d_d06daaf0",
        "filename": "obudec.c",
        "patchSetId": 1
      },
      "lineNbr": 48,
      "author": {
        "id": 5215
      },
      "writtenOn": "2018-04-30T23:58:34Z",
      "side": 1,
      "message": "Two things:\n\n1) I don\u0027t think we should be checking something that\u0027s already checked in the previous call. Why are we repeating the check? In other words, why repeat ourselves?\n\n2) Why replace the constant with len + 1? aom_uleb_decode is going to perform internal checks of the validity of input. The available length of output is OBU_MAX_LENGTH_FIELD_SIZE; not len + 1.\n\naom_uleb_decode has test coverage; this code does not (excepting shell tests). I\u0027d prefer that this code accept the outcome of the call w/test coverage over duplicating checks here.",
      "range": {
        "startLine": 48,
        "startChar": 43,
        "endLine": 48,
        "endChar": 50
      },
      "revId": "4f760a5b2b842a2333d06bcc5e87a772a8f9bfdc",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": true
    }
  ]
}