/*
 * Copyright (c) 2016, Alliance for Open Media. All rights reserved
 *
 * This source code is subject to the terms of the BSD 2 Clause License and
 * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License
 * was not distributed with this source code in the LICENSE file, you can
 * obtain it at www.aomedia.org/license/software. If the Alliance for Open
 * Media Patent License 1.0 was not distributed with this source code in the
 * PATENTS file, you can obtain it at www.aomedia.org/license/patent.
 */
#include <assert.h>

#include "av1/encoder/cost.h"
#include "av1/common/entropy.h"

#if CONFIG_LV_MAP_MULTI
const uint16_t av1_p9_cost[513] = {
  6656, 4563, 4073, 3781, 3573, 3410, 3277, 3164, 3066, 2980, 2903, 2833, 2769,
  2710, 2655, 2605, 2557, 2513, 2470, 2431, 2393, 2357, 2323, 2290, 2259, 2229,
  2200, 2172, 2145, 2119, 2094, 2070, 2047, 2024, 2002, 1980, 1960, 1940, 1920,
  1901, 1882, 1864, 1846, 1829, 1812, 1795, 1779, 1763, 1748, 1732, 1717, 1703,
  1688, 1674, 1661, 1647, 1634, 1621, 1608, 1595, 1583, 1571, 1559, 1547, 1535,
  1524, 1513, 1501, 1491, 1480, 1469, 1459, 1448, 1438, 1428, 1418, 1408, 1399,
  1389, 1380, 1371, 1361, 1352, 1343, 1335, 1326, 1317, 1309, 1300, 1292, 1284,
  1276, 1267, 1259, 1252, 1244, 1236, 1228, 1221, 1213, 1206, 1199, 1191, 1184,
  1177, 1170, 1163, 1156, 1149, 1142, 1136, 1129, 1122, 1116, 1109, 1103, 1096,
  1090, 1084, 1077, 1071, 1065, 1059, 1053, 1047, 1041, 1035, 1029, 1024, 1018,
  1012, 1007, 1001, 995,  990,  984,  979,  973,  968,  963,  957,  952,  947,
  942,  937,  932,  926,  921,  916,  911,  907,  902,  897,  892,  887,  882,
  878,  873,  868,  864,  859,  854,  850,  845,  841,  836,  832,  827,  823,
  818,  814,  810,  805,  801,  797,  793,  789,  784,  780,  776,  772,  768,
  764,  760,  756,  752,  748,  744,  740,  736,  732,  728,  724,  720,  717,
  713,  709,  705,  702,  698,  694,  690,  687,  683,  679,  676,  672,  669,
  665,  662,  658,  655,  651,  648,  644,  641,  637,  634,  630,  627,  624,
  620,  617,  614,  610,  607,  604,  601,  597,  594,  591,  588,  585,  581,
  578,  575,  572,  569,  566,  563,  559,  556,  553,  550,  547,  544,  541,
  538,  535,  532,  529,  526,  523,  521,  518,  515,  512,  509,  506,  503,
  500,  498,  495,  492,  489,  486,  484,  481,  478,  475,  472,  470,  467,
  464,  462,  459,  456,  454,  451,  448,  446,  443,  440,  438,  435,  433,
  430,  427,  425,  422,  420,  417,  415,  412,  410,  407,  405,  402,  400,
  397,  395,  392,  390,  387,  385,  382,  380,  378,  375,  373,  370,  368,
  366,  363,  361,  359,  356,  354,  352,  349,  347,  345,  342,  340,  338,
  336,  333,  331,  329,  327,  324,  322,  320,  318,  315,  313,  311,  309,
  307,  304,  302,  300,  298,  296,  294,  291,  289,  287,  285,  283,  281,
  279,  277,  275,  272,  270,  268,  266,  264,  262,  260,  258,  256,  254,
  252,  250,  248,  246,  244,  242,  240,  238,  236,  234,  232,  230,  228,
  226,  224,  222,  220,  218,  216,  214,  212,  210,  209,  207,  205,  203,
  201,  199,  197,  195,  193,  192,  190,  188,  186,  184,  182,  180,  179,
  177,  175,  173,  171,  169,  168,  166,  164,  162,  160,  159,  157,  155,
  153,  151,  150,  148,  146,  144,  143,  141,  139,  137,  136,  134,  132,
  131,  129,  127,  125,  124,  122,  120,  119,  117,  115,  114,  112,  110,
  108,  107,  105,  103,  102,  100,  99,   97,   95,   94,   92,   90,   89,
  87,   85,   84,   82,   81,   79,   77,   76,   74,   73,   71,   69,   68,
  66,   65,   63,   62,   60,   58,   57,   55,   54,   52,   51,   49,   48,
  46,   45,   43,   41,   40,   38,   37,   35,   34,   32,   31,   29,   28,
  26,   25,   23,   22,   20,   19,   17,   16,   14,   13,   12,   10,   9,
  7,    6,    4,    3,    1,    1
};
#endif

/* round(-log2(i/256.) * (1 << AV1_PROB_COST_SHIFT))
   Begins with a bogus entry for simpler addressing. */
const uint16_t av1_prob_cost[256] = {
  4096, 4096, 3584, 3284, 3072, 2907, 2772, 2659, 2560, 2473, 2395, 2325, 2260,
  2201, 2147, 2096, 2048, 2003, 1961, 1921, 1883, 1847, 1813, 1780, 1748, 1718,
  1689, 1661, 1635, 1609, 1584, 1559, 1536, 1513, 1491, 1470, 1449, 1429, 1409,
  1390, 1371, 1353, 1335, 1318, 1301, 1284, 1268, 1252, 1236, 1221, 1206, 1192,
  1177, 1163, 1149, 1136, 1123, 1110, 1097, 1084, 1072, 1059, 1047, 1036, 1024,
  1013, 1001, 990,  979,  968,  958,  947,  937,  927,  917,  907,  897,  887,
  878,  868,  859,  850,  841,  832,  823,  814,  806,  797,  789,  780,  772,
  764,  756,  748,  740,  732,  724,  717,  709,  702,  694,  687,  680,  673,
  665,  658,  651,  644,  637,  631,  624,  617,  611,  604,  598,  591,  585,
  578,  572,  566,  560,  554,  547,  541,  535,  530,  524,  518,  512,  506,
  501,  495,  489,  484,  478,  473,  467,  462,  456,  451,  446,  441,  435,
  430,  425,  420,  415,  410,  405,  400,  395,  390,  385,  380,  375,  371,
  366,  361,  356,  352,  347,  343,  338,  333,  329,  324,  320,  316,  311,
  307,  302,  298,  294,  289,  285,  281,  277,  273,  268,  264,  260,  256,
  252,  248,  244,  240,  236,  232,  228,  224,  220,  216,  212,  209,  205,
  201,  197,  194,  190,  186,  182,  179,  175,  171,  168,  164,  161,  157,
  153,  150,  146,  143,  139,  136,  132,  129,  125,  122,  119,  115,  112,
  109,  105,  102,  99,   95,   92,   89,   86,   82,   79,   76,   73,   70,
  66,   63,   60,   57,   54,   51,   48,   45,   42,   38,   35,   32,   29,
  26,   23,   20,   18,   15,   12,   9,    6,    3
};

static void cost(int *costs, aom_tree tree, const aom_prob *probs, int i,
                 int c) {
  const aom_prob prob = probs[i / 2];
  int b;

  assert(prob != 0);
  for (b = 0; b <= 1; ++b) {
    const int cc = c + av1_cost_bit(prob, b);
    const aom_tree_index ii = tree[i + b];

    if (ii <= 0)
      costs[-ii] = cc;
    else
      cost(costs, tree, probs, ii, cc);
  }
}

void av1_cost_tokens(int *costs, const aom_prob *probs, aom_tree tree) {
  cost(costs, tree, probs, 0, 0);
}

void av1_cost_tokens_skip(int *costs, const aom_prob *probs, aom_tree tree) {
  assert(tree[0] <= 0 && tree[1] > 0);

  costs[-tree[0]] = av1_cost_bit(probs[0], 0);
  cost(costs, tree, probs, 2, 0);
}

void av1_cost_tokens_from_cdf(int *costs, const aom_cdf_prob *cdf,
                              const int *inv_map) {
  int i;
  aom_cdf_prob prev_cdf = 0;
  for (i = 0;; ++i) {
#if CONFIG_LV_MAP_MULTI
    aom_cdf_prob p9 =
        ((AOM_ICDF(cdf[i]) >> EC_PROB_SHIFT) - (prev_cdf >> EC_PROB_SHIFT));
    assert(p9 < 512);
    if (inv_map)
      costs[inv_map[i]] = av1_p9_cost[p9];
    else
      costs[i] = av1_p9_cost[p9];
#else
    aom_cdf_prob p15 = AOM_ICDF(cdf[i]) - prev_cdf;
    prev_cdf = AOM_ICDF(cdf[i]);

    if (inv_map)
      costs[inv_map[i]] = av1_cost_symbol(p15);
    else
      costs[i] = av1_cost_symbol(p15);
#endif

    // Stop once we reach the end of the CDF
    if (cdf[i] == AOM_ICDF(CDF_PROB_TOP)) break;
  }
}
