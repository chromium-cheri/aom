{
  "comments": [
    {
      "key": {
        "uuid": "741e62f5_bd080b33",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 7,
      "author": {
        "id": 5435
      },
      "writtenOn": "2016-08-03T23:51:14Z",
      "side": 1,
      "message": "This looks like a third party library. Where is it from? Keeping it under third_party would make it easier to get updates and keep in sync without all the \u0027aom\u0027 renaming (although there doesn\u0027t appear to be much of that)",
      "revId": "ee61866293fc5dfcab46ae623516ad935b02e11a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "34830a89_008c662c",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 7,
      "author": {
        "id": 5111
      },
      "writtenOn": "2016-08-04T08:06:59Z",
      "side": 1,
      "message": "It has been written from scratch within Tandberg (acquired by Cisco), supporting various architectures, and cleaned up (with support only for x86 and arm) for the Thor codec.  There is no canonical source for this library.  Projects using it tend to add functionality as needed, possibly borrowing from other projects.",
      "parentUuid": "741e62f5_bd080b33",
      "revId": "ee61866293fc5dfcab46ae623516ad935b02e11a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "741e62f5_fd38c3d7",
        "filename": "aom_dsp/aom_simd.c",
        "patchSetId": 3
      },
      "lineNbr": 12,
      "author": {
        "id": 5435
      },
      "writtenOn": "2016-08-03T23:51:14Z",
      "side": 1,
      "message": "Could you integrate this into the existing RTCD system? It doesn\u0027t require setting up each function call with (aom_use_smd ? simd_func : c_func)",
      "revId": "ee61866293fc5dfcab46ae623516ad935b02e11a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "34830a89_60b292e2",
        "filename": "aom_dsp/aom_simd.c",
        "patchSetId": 3
      },
      "lineNbr": 12,
      "author": {
        "id": 5111
      },
      "writtenOn": "2016-08-04T08:06:59Z",
      "side": 1,
      "message": "The objective must be to write a function once, and compile it several times with different defines enabled, so we get an SSE2 version, an SSSE3 version, etc.  I think it\u0027s possible by editing the makefiles and having these functions in a separate file (which is compiled multiple times) and using the HAVE_SSSE3 type defines to add a postfix to the function name.  So I don\u0027t think there\u0027s a need to change the library to support this, perhaps apart from using the HAVE_SSSE3 type defines instead of the compiler defines in the v64_ and v128_ functions.",
      "parentUuid": "741e62f5_fd38c3d7",
      "revId": "ee61866293fc5dfcab46ae623516ad935b02e11a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "741e62f5_bd6d6bd7",
        "filename": "aom_dsp/aom_simd.h",
        "patchSetId": 3
      },
      "lineNbr": 36,
      "author": {
        "id": 5435
      },
      "writtenOn": "2016-08-03T23:51:14Z",
      "side": 1,
      "message": "This seems incredibly restrictive. Do you have plans for this to support higher X86 optimizations? Do you have benchmarks between native intrinsics and these functions?",
      "range": {
        "startLine": 36,
        "startChar": 14,
        "endLine": 36,
        "endChar": 22
      },
      "revId": "ee61866293fc5dfcab46ae623516ad935b02e11a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "34830a89_c0819ef8",
        "filename": "aom_dsp/aom_simd.h",
        "patchSetId": 3
      },
      "lineNbr": 36,
      "author": {
        "id": 5111
      },
      "writtenOn": "2016-08-04T08:06:59Z",
      "side": 1,
      "message": "Only a few functions benefit from higher optimisations (see other comment).  But if support for a v256 type is to be added, AVX becomes essential.",
      "parentUuid": "741e62f5_bd6d6bd7",
      "range": {
        "startLine": 36,
        "startChar": 14,
        "endLine": 36,
        "endChar": 22
      },
      "revId": "ee61866293fc5dfcab46ae623516ad935b02e11a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "741e62f5_1d425747",
        "filename": "aom_dsp/aom_simd.h",
        "patchSetId": 3
      },
      "lineNbr": 46,
      "author": {
        "id": 5435
      },
      "writtenOn": "2016-08-03T23:51:14Z",
      "side": 1,
      "message": "Why not use your big_endian() function here?",
      "revId": "ee61866293fc5dfcab46ae623516ad935b02e11a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "741e62f5_4098e263",
        "filename": "aom_dsp/simd/v128_intrinsics_x86.h",
        "patchSetId": 3
      },
      "lineNbr": 244,
      "author": {
        "id": 5435
      },
      "writtenOn": "2016-08-04T00:10:21Z",
      "side": 1,
      "message": "Ah, I see how it allows for higher optimization levels here. While this makes sense when one builds on a given target and only runs on that target, it makes it difficult to distribute a single binary supporting multiple targets.\n\nThere are also existing defines in AOM for these, such as HAVE_SSSE3, which can be turned off (--disable-ssse3) at compile time if you plan on running on a device without them. Is there a way to do that with this library?",
      "revId": "ee61866293fc5dfcab46ae623516ad935b02e11a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "34830a89_609b7262",
        "filename": "aom_dsp/simd/v128_intrinsics_x86.h",
        "patchSetId": 3
      },
      "lineNbr": 244,
      "author": {
        "id": 5111
      },
      "writtenOn": "2016-08-04T08:06:59Z",
      "side": 1,
      "message": "Yes, I see your point.  But it also means that every kernel function needing higher optimisation levels would have to be duplicated, or is there a cleaner way to do this?\n\nSSE4 is 10 years old now, are we addressing an actual problem?\n\nThe library depends on compiler defines (so you must pass compiler options to switch them off, if possible), but we could use aom defines (it then becomes dependent on aom, though).  If you think it makes more sense, I\u0027m happy with switching to HAVE_SSSE3.",
      "parentUuid": "741e62f5_4098e263",
      "revId": "ee61866293fc5dfcab46ae623516ad935b02e11a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "34830a89_a0865abe",
        "filename": "aom_dsp/simd/v128_intrinsics_x86.h",
        "patchSetId": 3
      },
      "lineNbr": 244,
      "author": {
        "id": 5111
      },
      "writtenOn": "2016-08-04T12:05:39Z",
      "side": 1,
      "message": "I changed to use HAVE_SSSE3 etc, but reverted that, since HAVE_SSSE3 might be enabled yet -mssse3 was not passed to the compiler, unless the file name ends in _ssse3.\n\nI\u0027m adding optimisations for CLPF now and figuring out how to do it allowing multiple versions in one binary.  In the Makefile:\n\nAV1_COMMON_SRCS-$(HAVE_SSE2) +\u003d common/clpf_sse2.c\nAV1_COMMON_SRCS-$(HAVE_SSSE3) +\u003d common/clpf_ssse3.c\nAV1_COMMON_SRCS-$(HAVE_SSE4_1) +\u003d common/clpf_sse4.c\n\nThese files will be on the form:\n\n#include \"aom_dsp/aom_simd.h\"\n#define SIMD_FUNC(name) name ## _sse2\n#include \"./clpf_kernels.c\"\n\nAnd clpf_kernels.c will hold the actual functions which must be named with the SIMD_FUNC macro:\n\nvoid SIMD_FUNC(clpf_block4)(...)\n\nThen we get three versions: clpf_block_sse2, clpf_block_ssse3 and clpf_block_sse4.  It\u0027s also possible to create an intrinsics free implementation in a similar fashion, but code using the C implementations of the intrinsics will usually be slower than a plain C version of the same kernel.",
      "parentUuid": "34830a89_609b7262",
      "revId": "ee61866293fc5dfcab46ae623516ad935b02e11a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    }
  ]
}