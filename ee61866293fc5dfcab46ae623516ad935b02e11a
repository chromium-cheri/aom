{
  "comments": [
    {
      "key": {
        "uuid": "741e62f5_bd080b33",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 7,
      "author": {
        "id": 5435
      },
      "writtenOn": "2016-08-03T23:51:14Z",
      "side": 1,
      "message": "This looks like a third party library. Where is it from? Keeping it under third_party would make it easier to get updates and keep in sync without all the \u0027aom\u0027 renaming (although there doesn\u0027t appear to be much of that)",
      "revId": "ee61866293fc5dfcab46ae623516ad935b02e11a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "34830a89_008c662c",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 7,
      "author": {
        "id": 5111
      },
      "writtenOn": "2016-08-04T08:06:59Z",
      "side": 1,
      "message": "It has been written from scratch within Tandberg (acquired by Cisco), supporting various architectures, and cleaned up (with support only for x86 and arm) for the Thor codec.  There is no canonical source for this library.  Projects using it tend to add functionality as needed, possibly borrowing from other projects.",
      "parentUuid": "741e62f5_bd080b33",
      "revId": "ee61866293fc5dfcab46ae623516ad935b02e11a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f4797274_aae1d72d",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 7,
      "author": {
        "id": 5435
      },
      "writtenOn": "2016-08-05T00:57:34Z",
      "side": 1,
      "message": "That sounds like x86inc.asm. It\u0027s from ffmpeg/libav/x264 but each of those keeps it\u0027s own version. They kind of cherry-pick changes back and forth but when I was looking to update third_party/x86inc it was really frustrating not knowing which was \"canonical\" and trying to figure out what patches were redundant etc.\n\nBecause of that I\u0027d like to see it in third_party/ with a README about it\u0027s history and who else is using it and which of those sources was used for this version. I\u0027ve talked to someone else who is already excited about it and is curious about avx2/avx512 and it would be a shame to see that work duplicated because different people are doing it in different ways.",
      "parentUuid": "34830a89_008c662c",
      "revId": "ee61866293fc5dfcab46ae623516ad935b02e11a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "79373bdb_12a4eca0",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 7,
      "author": {
        "id": 5111
      },
      "writtenOn": "2016-08-05T07:30:54Z",
      "side": 1,
      "message": "This is a kind of library which is hard to define a canon for, since every project using it tends to have very specialised needs.  Trying to bring all that together will quickly make the library explode in size.\nI think a canon would have to be a simple form with a relatively small set of function, perhaps very close to its current form.",
      "parentUuid": "f4797274_aae1d72d",
      "revId": "ee61866293fc5dfcab46ae623516ad935b02e11a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "741e62f5_fd38c3d7",
        "filename": "aom_dsp/aom_simd.c",
        "patchSetId": 3
      },
      "lineNbr": 12,
      "author": {
        "id": 5435
      },
      "writtenOn": "2016-08-03T23:51:14Z",
      "side": 1,
      "message": "Could you integrate this into the existing RTCD system? It doesn\u0027t require setting up each function call with (aom_use_smd ? simd_func : c_func)",
      "revId": "ee61866293fc5dfcab46ae623516ad935b02e11a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "34830a89_60b292e2",
        "filename": "aom_dsp/aom_simd.c",
        "patchSetId": 3
      },
      "lineNbr": 12,
      "author": {
        "id": 5111
      },
      "writtenOn": "2016-08-04T08:06:59Z",
      "side": 1,
      "message": "The objective must be to write a function once, and compile it several times with different defines enabled, so we get an SSE2 version, an SSSE3 version, etc.  I think it\u0027s possible by editing the makefiles and having these functions in a separate file (which is compiled multiple times) and using the HAVE_SSSE3 type defines to add a postfix to the function name.  So I don\u0027t think there\u0027s a need to change the library to support this, perhaps apart from using the HAVE_SSSE3 type defines instead of the compiler defines in the v64_ and v128_ functions.",
      "parentUuid": "741e62f5_fd38c3d7",
      "revId": "ee61866293fc5dfcab46ae623516ad935b02e11a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f4797274_ca49b339",
        "filename": "aom_dsp/aom_simd.c",
        "patchSetId": 3
      },
      "lineNbr": 12,
      "author": {
        "id": 5435
      },
      "writtenOn": "2016-08-05T00:57:34Z",
      "side": 1,
      "message": "I think using this system to generate _ssse3, _avx, _neon etc functions and using the existing RTCD system would be much better. It would allow it to coexist with the other optimizations without restricting more specific optimizations when this library isn\u0027t able to help.",
      "parentUuid": "34830a89_60b292e2",
      "revId": "ee61866293fc5dfcab46ae623516ad935b02e11a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "741e62f5_bd6d6bd7",
        "filename": "aom_dsp/aom_simd.h",
        "patchSetId": 3
      },
      "lineNbr": 36,
      "author": {
        "id": 5435
      },
      "writtenOn": "2016-08-03T23:51:14Z",
      "side": 1,
      "message": "This seems incredibly restrictive. Do you have plans for this to support higher X86 optimizations? Do you have benchmarks between native intrinsics and these functions?",
      "range": {
        "startLine": 36,
        "startChar": 14,
        "endLine": 36,
        "endChar": 22
      },
      "revId": "ee61866293fc5dfcab46ae623516ad935b02e11a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "34830a89_c0819ef8",
        "filename": "aom_dsp/aom_simd.h",
        "patchSetId": 3
      },
      "lineNbr": 36,
      "author": {
        "id": 5111
      },
      "writtenOn": "2016-08-04T08:06:59Z",
      "side": 1,
      "message": "Only a few functions benefit from higher optimisations (see other comment).  But if support for a v256 type is to be added, AVX becomes essential.",
      "parentUuid": "741e62f5_bd6d6bd7",
      "range": {
        "startLine": 36,
        "startChar": 14,
        "endLine": 36,
        "endChar": 22
      },
      "revId": "ee61866293fc5dfcab46ae623516ad935b02e11a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f4797274_8acdfbb7",
        "filename": "aom_dsp/aom_simd.h",
        "patchSetId": 3
      },
      "lineNbr": 36,
      "author": {
        "id": 5435
      },
      "writtenOn": "2016-08-05T00:57:34Z",
      "side": 1,
      "message": "The downside to v256 is it no longer maps to neon, which only has v128.",
      "parentUuid": "34830a89_c0819ef8",
      "range": {
        "startLine": 36,
        "startChar": 14,
        "endLine": 36,
        "endChar": 22
      },
      "revId": "ee61866293fc5dfcab46ae623516ad935b02e11a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "79373bdb_329ff04a",
        "filename": "aom_dsp/aom_simd.h",
        "patchSetId": 3
      },
      "lineNbr": 36,
      "author": {
        "id": 5111
      },
      "writtenOn": "2016-08-05T07:30:54Z",
      "side": 1,
      "message": "It\u0027s not a big problem.  One would just have to write a v256 version for neon, which in most cases would use pairs of v128 instructions.  Look how much of v128_intrinsics_c.h has been implemented.  We have written v128 implementations for dsp\u0027s with only 64 bit wide and even just 32 bit wide registers, and it worked well enough to release products running quite a bit of v128 code.  The possible downside is that if you write code using v256, it\u0027s kind of like doing explicit unrolling if the underlying architectures doesn\u0027t have that wide registers, which may or may not be a good thing.",
      "parentUuid": "f4797274_8acdfbb7",
      "range": {
        "startLine": 36,
        "startChar": 14,
        "endLine": 36,
        "endChar": 22
      },
      "revId": "ee61866293fc5dfcab46ae623516ad935b02e11a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "741e62f5_1d425747",
        "filename": "aom_dsp/aom_simd.h",
        "patchSetId": 3
      },
      "lineNbr": 46,
      "author": {
        "id": 5435
      },
      "writtenOn": "2016-08-03T23:51:14Z",
      "side": 1,
      "message": "Why not use your big_endian() function here?",
      "revId": "ee61866293fc5dfcab46ae623516ad935b02e11a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f4797274_4a5683d2",
        "filename": "aom_dsp/simd/v128_intrinsics_arm.h",
        "patchSetId": 3
      },
      "lineNbr": 285,
      "author": {
        "id": 5435
      },
      "writtenOn": "2016-08-05T00:57:34Z",
      "side": 1,
      "message": "vzipq for a transpose is substantially less effective that vtrnq.",
      "revId": "ee61866293fc5dfcab46ae623516ad935b02e11a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "79373bdb_72a578a0",
        "filename": "aom_dsp/simd/v128_intrinsics_arm.h",
        "patchSetId": 3
      },
      "lineNbr": 285,
      "author": {
        "id": 5111
      },
      "writtenOn": "2016-08-05T07:30:54Z",
      "side": 1,
      "message": "Yes, this library doesn\u0027t exploit all nice instructions in all architectures.  The approach to that problem so far has been that if this causes a significant performance drop for one architecture, we have two choices: Write a special version for that architecture only, or add a new intrinsic, in this case perhaps void v128_transpose_8(v128 *x, v128 *y) which gets a trivial implementation for arm and a compound implementation on x86 using unpack instructions, which I think in this case will allow shared, optimal code for both x86 and arm.  A balance between usefulness and the size of the library must be maintained.",
      "parentUuid": "f4797274_4a5683d2",
      "revId": "ee61866293fc5dfcab46ae623516ad935b02e11a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "741e62f5_4098e263",
        "filename": "aom_dsp/simd/v128_intrinsics_x86.h",
        "patchSetId": 3
      },
      "lineNbr": 244,
      "author": {
        "id": 5435
      },
      "writtenOn": "2016-08-04T00:10:21Z",
      "side": 1,
      "message": "Ah, I see how it allows for higher optimization levels here. While this makes sense when one builds on a given target and only runs on that target, it makes it difficult to distribute a single binary supporting multiple targets.\n\nThere are also existing defines in AOM for these, such as HAVE_SSSE3, which can be turned off (--disable-ssse3) at compile time if you plan on running on a device without them. Is there a way to do that with this library?",
      "revId": "ee61866293fc5dfcab46ae623516ad935b02e11a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "34830a89_609b7262",
        "filename": "aom_dsp/simd/v128_intrinsics_x86.h",
        "patchSetId": 3
      },
      "lineNbr": 244,
      "author": {
        "id": 5111
      },
      "writtenOn": "2016-08-04T08:06:59Z",
      "side": 1,
      "message": "Yes, I see your point.  But it also means that every kernel function needing higher optimisation levels would have to be duplicated, or is there a cleaner way to do this?\n\nSSE4 is 10 years old now, are we addressing an actual problem?\n\nThe library depends on compiler defines (so you must pass compiler options to switch them off, if possible), but we could use aom defines (it then becomes dependent on aom, though).  If you think it makes more sense, I\u0027m happy with switching to HAVE_SSSE3.",
      "parentUuid": "741e62f5_4098e263",
      "revId": "ee61866293fc5dfcab46ae623516ad935b02e11a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "34830a89_a0865abe",
        "filename": "aom_dsp/simd/v128_intrinsics_x86.h",
        "patchSetId": 3
      },
      "lineNbr": 244,
      "author": {
        "id": 5111
      },
      "writtenOn": "2016-08-04T12:05:39Z",
      "side": 1,
      "message": "I changed to use HAVE_SSSE3 etc, but reverted that, since HAVE_SSSE3 might be enabled yet -mssse3 was not passed to the compiler, unless the file name ends in _ssse3.\n\nI\u0027m adding optimisations for CLPF now and figuring out how to do it allowing multiple versions in one binary.  In the Makefile:\n\nAV1_COMMON_SRCS-$(HAVE_SSE2) +\u003d common/clpf_sse2.c\nAV1_COMMON_SRCS-$(HAVE_SSSE3) +\u003d common/clpf_ssse3.c\nAV1_COMMON_SRCS-$(HAVE_SSE4_1) +\u003d common/clpf_sse4.c\n\nThese files will be on the form:\n\n#include \"aom_dsp/aom_simd.h\"\n#define SIMD_FUNC(name) name ## _sse2\n#include \"./clpf_kernels.c\"\n\nAnd clpf_kernels.c will hold the actual functions which must be named with the SIMD_FUNC macro:\n\nvoid SIMD_FUNC(clpf_block4)(...)\n\nThen we get three versions: clpf_block_sse2, clpf_block_ssse3 and clpf_block_sse4.  It\u0027s also possible to create an intrinsics free implementation in a similar fashion, but code using the C implementations of the intrinsics will usually be slower than a plain C version of the same kernel.",
      "parentUuid": "34830a89_609b7262",
      "revId": "ee61866293fc5dfcab46ae623516ad935b02e11a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f4797274_cacc5392",
        "filename": "aom_dsp/simd/v128_intrinsics_x86.h",
        "patchSetId": 3
      },
      "lineNbr": 244,
      "author": {
        "id": 5435
      },
      "writtenOn": "2016-08-05T00:59:43Z",
      "side": 1,
      "message": "Ah sorry it sounds like you are working on adding the clpf functions as examples? I\u0027m not familiar with that function but I\u0027ll take a look through vp10/common/clpf.c and look forward to your example. Thanks!",
      "parentUuid": "34830a89_a0865abe",
      "revId": "ee61866293fc5dfcab46ae623516ad935b02e11a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "79373bdb_92969c37",
        "filename": "aom_dsp/simd/v128_intrinsics_x86.h",
        "patchSetId": 3
      },
      "lineNbr": 244,
      "author": {
        "id": 5111
      },
      "writtenOn": "2016-08-05T07:30:54Z",
      "side": 1,
      "message": "Yes, I\u0027m proposing this library to avoid multiple versions of SIMD optimised functions for CLPF (and possibly other future contributions).  In my opinion, to maintain and test versions for sse2, ssse3, sse4.1 and neon will be an unneccesary pain.  I\u0027m not proposing that existing optimisations should be converted, unless somebody sees any benefits for doing so.\nI\u0027ll look into the RTCD system and work out how things will look for CLPF within that framework.",
      "parentUuid": "f4797274_cacc5392",
      "revId": "ee61866293fc5dfcab46ae623516ad935b02e11a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    }
  ]
}