{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "6e96d5c3_b4b59998",
        "filename": "aom_dsp/arm/mem_neon.h",
        "patchSetId": 1
      },
      "lineNbr": 104,
      "author": {
        "id": 5020
      },
      "writtenOn": "2023-11-03T17:28:48Z",
      "side": 1,
      "message": "does `vld1_dup_u32` produce better code in this and the next instance?",
      "revId": "7ec3ab55191e6ef5ea5d7d261f5a726377fc489e",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "28b43e7b_f30691e0",
        "filename": "aom_dsp/arm/mem_neon.h",
        "patchSetId": 1
      },
      "lineNbr": 104,
      "author": {
        "id": 31817
      },
      "writtenOn": "2023-11-03T17:41:12Z",
      "side": 1,
      "message": "I think no. Judging by https://godbolt.org/z/na7q6shjP it seems like the current code is better, at least on recent compilers:\na) both GCC and Clang are able to see that a standard scalar load will already zero the upper portion of the register and therefore can elide the zeroing in the existing code.\nb) Clang additionally recognises that the LD1R is pointless in the vld1_dup_u32 case so emits identical asm to the existing one, but GCC isn\u0027t able to do this yet by the looks of things and emits the LD1R instead. LD1R tends to perform worse than a standard load since it involves an additional permute, although this depends on the micro-architecture.",
      "parentUuid": "6e96d5c3_b4b59998",
      "revId": "7ec3ab55191e6ef5ea5d7d261f5a726377fc489e",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    }
  ]
}