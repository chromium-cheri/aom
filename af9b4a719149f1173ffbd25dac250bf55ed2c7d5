{
  "comments": [
    {
      "key": {
        "uuid": "18e13ca5_6fa854de",
        "filename": "av1/av1_dx_iface.c",
        "patchSetId": 1
      },
      "lineNbr": 767,
      "author": {
        "id": 5215
      },
      "writtenOn": "2019-12-10T17:35:11Z",
      "side": 1,
      "message": "I think move_ or transfer_ would be a better prefix given the semantics here, but outside of the naming nit this looks fine.",
      "range": {
        "startLine": 767,
        "startChar": 12,
        "endLine": 767,
        "endChar": 17
      },
      "revId": "af9b4a719149f1173ffbd25dac250bf55ed2c7d5",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cbbe0142_452c1846",
        "filename": "av1/av1_dx_iface.c",
        "patchSetId": 1
      },
      "lineNbr": 767,
      "author": {
        "id": 14148
      },
      "writtenOn": "2019-12-10T23:42:43Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "18e13ca5_6fa854de",
      "range": {
        "startLine": 767,
        "startChar": 12,
        "endLine": 767,
        "endChar": 17
      },
      "revId": "af9b4a719149f1173ffbd25dac250bf55ed2c7d5",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "47d52243_626c19fa",
        "filename": "av1/av1_dx_iface.c",
        "patchSetId": 1
      },
      "lineNbr": 822,
      "author": {
        "id": 14148
      },
      "writtenOn": "2019-12-09T22:33:13Z",
      "side": 1,
      "message": "Added this to prevent ctx-\u003eimg from keeping the metadata from past frame, since the object is being re utilized on every decode loop. Also, yuvconfig2image metadata pointer copy was a possible leak cause.",
      "range": {
        "startLine": 820,
        "startChar": 0,
        "endLine": 822,
        "endChar": 55
      },
      "revId": "af9b4a719149f1173ffbd25dac250bf55ed2c7d5",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a7beb918_22d5b48a",
        "filename": "av1/av1_dx_iface.c",
        "patchSetId": 1
      },
      "lineNbr": 829,
      "author": {
        "id": 14148
      },
      "writtenOn": "2019-12-09T22:33:13Z",
      "side": 1,
      "message": "ditto above comment.",
      "range": {
        "startLine": 827,
        "startChar": 0,
        "endLine": 829,
        "endChar": 57
      },
      "revId": "af9b4a719149f1173ffbd25dac250bf55ed2c7d5",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1c18a047_d637ea86",
        "filename": "test/metadata_test.cc",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5215
      },
      "writtenOn": "2019-12-10T17:35:11Z",
      "side": 1,
      "message": "I think some explicit testing of failure modes would be a good thing to add before landing this. It will reduce the likelihood of a revert if you handle some foreseeable failure modes that will be caused by fuzzing:\n\n- Truncated metadata OBUs\n- Metadata OBUs w/invalid sizes (i.e. more payload than reported meaning the stream is essentially garbage)\n- Invalid T35 payload (kind the same as the previous example, but failing within the contents if there\u0027s a place where it could occur).\n\nYou\u0027ll probably think of a few more cases (or encounter them directly) while writing these kinds of tests. To be clear, I\u0027m not looking for you to work magic and make the decoder recover when it encounters data with the above example characteristics, just that we\u0027re failing gracefully and not leaking memory.",
      "revId": "af9b4a719149f1173ffbd25dac250bf55ed2c7d5",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ba3339b3_b2f8e26f",
        "filename": "test/metadata_test.cc",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 14148
      },
      "writtenOn": "2019-12-10T23:42:43Z",
      "side": 1,
      "message": "Are these tests are to be done using only the metadata public functions that were added?\n\nSince the syntax of itu_t_t35_payload_bytes are not defined in the spec, the only validation I can think of for T35 integrity is that it contains the country_code bytes at the start, yet this can be any byte as per their spec. All other payload bytes are user specific.\nFor the others, considering we only validate T35 case, even if garbage is added as payload if user specifies larger size than his data, it would be taken as valid as payload bytes are user specific. \n\nThis could be due to nature of T35 or maybe I\u0027m misunderstanding the case and broader tests are needed.",
      "parentUuid": "1c18a047_d637ea86",
      "revId": "af9b4a719149f1173ffbd25dac250bf55ed2c7d5",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a144026e_481e2f52",
        "filename": "test/metadata_test.cc",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5215
      },
      "writtenOn": "2019-12-11T01:21:10Z",
      "side": 1,
      "message": "\u003e Are these tests are to be done using only the metadata public functions that were added?\n\nNot necessarily. I\u0027m mainly concerned that we have the same test set that missed the failure modes in the bugs this reland of the patch addresses.\n\n\u003e Since the syntax of itu_t_t35_payload_bytes are not defined in the spec, the only validation I can think of for T35 \n\u003e integrity is that it contains the country_code bytes at the start, yet this can be any byte as per their spec. All \n\u003e other payload bytes are user specific.\n\u003e For the others, considering we only validate T35 case, even if garbage is added as payload if user specifies larger \n\u003e size than his data, it would be taken as valid as payload bytes are user specific. \n\u003e\n\u003e This could be due to nature of T35 or maybe I\u0027m misunderstanding the case and broader tests are needed.\n\nI see your point on the T35 payload case. My main concern is that we\u0027re going to be doing this again in a week once all the longer running tests have another go at the patch.\n\n\u003e \u003e Truncated metadata OBUs\n\u003e \u003e Metadata OBUs w/invalid sizes (i.e. more payload than reported meaning the stream is essentially garbage)\n\nThese could still be tested-- a fuzzer will happily replace an OBU size field with a bogus number that\u0027s larger than the OBU payload. Confirming that such a case is handled gracefully when the fuzzed OBU size is for a metadata OBU seems reasonable. However, I\u0027m not sure of the feasibility of such a test given the current structure of the OBU parsing code.\n\nAnyway, I\u0027m fine with the patch as-is, but I\u0027ll let wtc@ have a look before we land this.",
      "parentUuid": "ba3339b3_b2f8e26f",
      "revId": "af9b4a719149f1173ffbd25dac250bf55ed2c7d5",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": true
    }
  ]
}