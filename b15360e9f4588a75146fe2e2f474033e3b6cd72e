{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "5e3e3161_c2ffb3c7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 9545
      },
      "writtenOn": "2022-06-03T19:21:16Z",
      "side": 1,
      "message": "Hi Bohan,\n\nI have some questions about this CL. Please see my comments below.",
      "revId": "b15360e9f4588a75146fe2e2f474033e3b6cd72e",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "015582a5_49f40025",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 5020
      },
      "writtenOn": "2022-06-03T19:24:35Z",
      "side": 1,
      "message": "Wan-Teh, for context the change was based on my comment here:\nhttp://ffmpeg.org/pipermail/ffmpeg-devel/2022-May/296795.html\n\nwithout it the wrapper would report all operating points even if there was only one in use.",
      "revId": "b15360e9f4588a75146fe2e2f474033e3b6cd72e",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "25d5c265_f42b1dbf",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 9545
      },
      "writtenOn": "2022-06-03T21:02:19Z",
      "side": 1,
      "message": "Thanks for the context. The fundamental problem is that the wrapper does not know how many operating points there are.\n\nNote that AV1E_SET_TARGET_SEQ_LEVEL_IDX also allows a target seq_level_idx to be set to 31, so if a target seq_level_idx is 31, it is ambiguous whether that is the default value or an explicitly set value. This means the following ffmpeg code in libavcodec/libaomenc.c will malfunction if a target seq_level_idx is explicitly set to 31:\n\n                } else if (target_levels[i] \u003c 31) {\n                    // Log the encoded level if a target level was given\n                    av_log(avctx, AV_LOG_INFO,\n                           \"Output level for operating point %d is %d.%d.\\n\",\n                           i, 2 + (levels[i] \u003e\u003e 2), levels[i] \u0026 3);\n                }\n\nAlso, the current libavcodec/libaomenc.c in ffmpeg does not use AV1E_SET_SVC_PARAMS or AOME_SET_NUMBER_SPATIAL_LAYERS, so the number of operating points is always 1. But we probably should not depend on that. Maybe we should add a codec control to get the number of operating points.",
      "parentUuid": "015582a5_49f40025",
      "revId": "b15360e9f4588a75146fe2e2f474033e3b6cd72e",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "79a8c279_c0530b48",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 7525
      },
      "writtenOn": "2022-06-03T21:05:47Z",
      "side": 1,
      "message": "To add a bit here, although it is allowed to set target seq level idx to be 31, that basically is saying we do not have any constraint on the bitstream level and in that case I don\u0027t think it is necessarily \"malfunction\" that we do not output anything?",
      "parentUuid": "25d5c265_f42b1dbf",
      "revId": "b15360e9f4588a75146fe2e2f474033e3b6cd72e",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2971a233_e004ae56",
        "filename": "av1/encoder/level.c",
        "patchSetId": 3
      },
      "lineNbr": 1250,
      "author": {
        "id": 9545
      },
      "writtenOn": "2022-06-03T19:21:16Z",
      "side": 1,
      "message": "Note that these three lines are the same as the first three lines of the original code of av1_get_target_seq_level_idx(). At first glance it seems that this function should also initialize the entire seq_level_idx array to SEQ_LEVEL_MAX. But I think a more fundamental problem is that the caller does not know the actual size of the array (seq_params-\u003eoperating_points_cnt_minus_1 + 1), so it \"blindly\" checks all 32 entries in the array.",
      "revId": "b15360e9f4588a75146fe2e2f474033e3b6cd72e",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "48492fcd_e9aa5b7b",
        "filename": "av1/encoder/level.c",
        "patchSetId": 3
      },
      "lineNbr": 1271,
      "author": {
        "id": 9545
      },
      "writtenOn": "2022-06-06T16:55:34Z",
      "side": 1,
      "message": "Strictly speaking, this change can be considered as an incompatible change, because it assumes the output array target_seq_level_idx has at least 32 (\u003d MAX_NUM_OPERATING_POINTS) elements. Previously, if a user knew there was only one operating point (the default case), the user could pass an output array of size one, which seemed to be allowed by our documentation:\n\n```\n  /*!\\brief Codec control function to get the target sequence level index for\n   * each operating point. int* parameter. There can be at most 32 operating\n   * points. The results will be written into a provided integer array of\n   * sufficient size. If a target level is not set, the result will be 31.\n   * Please refer to https://aomediacodec.github.io/av1-spec/#levels for more\n   * details on level definitions and indices.\n   */\n  AV1E_GET_TARGET_SEQ_LEVEL_IDX \u003d 155,\n```\n\nThe comment \"a provided integer array of sufficient size\" could be interpreted to mean \"a provided integer array of a size greater than or equal to the number of operating points\".",
      "revId": "b15360e9f4588a75146fe2e2f474033e3b6cd72e",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "104a94d1_15150ff4",
        "filename": "av1/encoder/level.c",
        "patchSetId": 3
      },
      "lineNbr": 1280,
      "author": {
        "id": 9545
      },
      "writtenOn": "2022-06-03T19:21:16Z",
      "side": 1,
      "message": "Bohan, could you explain why this change is needed?\n \nI found that av1_get_target_seq_level_idx() and the related av1_get_seq_level_idx() function above are only used in aomenc.c (except test/level_test.cc):\n\n \n```\n    if (pass \u003d\u003d global.passes - 1) {\n      FOREACH_STREAM(stream, streams) {\n        int levels[32] \u003d { 0 };\n        int target_levels[32] \u003d { 0 };\n        aom_codec_control(\u0026stream-\u003eencoder, AV1E_GET_SEQ_LEVEL_IDX, levels);\n        aom_codec_control(\u0026stream-\u003eencoder, AV1E_GET_TARGET_SEQ_LEVEL_IDX,\n                          target_levels);\n\n        for (int i \u003d 0; i \u003c 32; i++) {\n          if (levels[i] \u003e target_levels[i]) {\n            aom_tools_warn(\n                \"Failed to encode to target level %d.%d for operating point \"\n                \"%d. The output level is %d.%d\",\n                2 + (target_levels[i] \u003e\u003e 2), target_levels[i] \u0026 3, i,\n                2 + (levels[i] \u003e\u003e 2), levels[i] \u0026 3);\n          }\n        }\n      }\n    }\n```\n\nThe for loop inspects all 32 elements of the levels and target_levels arrays, but only the first seq_params-\u003eoperating_points_cnt_minus_1 + 1 elements of those two arrays should be used.\n\nAlso, the original code should not cause this for loop to malfunction, because the unused elements in the two arrays will be both equal to 0 (the initial value). So I guess this change fixes some other problem. Is it because you want to implement the comment \"If a target level is not set, the result will be 31.\"?\n\n```\n  /*!\\brief Codec control function to get the target sequence level index for\n   * each operating point. int* parameter. There can be at most 32 operating\n   * points. The results will be written into a provided integer array of\n   * sufficient size. If a target level is not set, the result will be 31.\n   * Please refer to https://aomediacodec.github.io/av1-spec/#levels for more\n   * details on level definitions and indices.\n   */\n  AV1E_GET_TARGET_SEQ_LEVEL_IDX \u003d 155,\n```",
      "revId": "b15360e9f4588a75146fe2e2f474033e3b6cd72e",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a72787e6_78aed566",
        "filename": "av1/encoder/level.c",
        "patchSetId": 3
      },
      "lineNbr": 1280,
      "author": {
        "id": 7525
      },
      "writtenOn": "2022-06-03T21:05:47Z",
      "side": 1,
      "message": "Hi Wan-Teh, thanks for the comments. Yes I think your observations are correct. Basically this patch is to make sure that we output 31 when the target seq level is not set. This is used by aomenc, and also possibly other clients like ffmpeg.",
      "parentUuid": "104a94d1_15150ff4",
      "revId": "b15360e9f4588a75146fe2e2f474033e3b6cd72e",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "96f162a8_d739f926",
        "filename": "av1/encoder/level.c",
        "patchSetId": 3
      },
      "lineNbr": 1280,
      "author": {
        "id": 9545
      },
      "writtenOn": "2022-06-06T16:55:34Z",
      "side": 1,
      "message": "Hi Bohan,\n\nThank you for the reply. I studied how AV1E_GET_SEQ_LEVEL_IDX and AV1E_GET_TARGET_SEQ_LEVEL_IDX are used by aomenc and ffmpeg/libavcodec/libaomenc.c. I understand the problem now. There seem to be two reasonable solutions.\n\n1. Leave AV1E_GET_SEQ_LEVEL_IDX and AV1E_GET_TARGET_SEQ_LEVEL_IDX unchanged. (This means reverting this CL.) Add a new codec control, AV1E_GET_NUM_OPERATING_POINTS, that returns the value of `seq_params-\u003eoperating_points_cnt_minus_1 + 1`. Suppose that value is N. Then modify aomenc and ffmpeg/libavcodec/libaomenc.c to only inspect the first N elements in the `levels` and `target_levels` arrays.\n\nThis is the preferred solution because it tells the users of AV1E_GET_SEQ_LEVEL_IDX and AV1E_GET_TARGET_SEQ_LEVEL_IDX explicitly how many entries in the output arrays are in use, so that the unused entries are skipped.\n\n2. Change both AV1E_GET_SEQ_LEVEL_IDX and AV1E_GET_TARGET_SEQ_LEVEL_IDX to initialize the unused entries in the output arrays to SEQ_LEVEL_MAX. This means changing av1_get_seq_level_idx() similar to how this CL changed av1_get_target_seq_level_idx().\n\nRationale: Since the current code in both aomenc and ffmpeg/libavcodec/libaomenc.c compares `levels[i]` with `target_levels[i]`, the unused entries in these two arrays should be set to a value that allows the comparison of unused entries to be meaningful.\n\nIf we allow aomenc and ffmpeg/libavcodec/libaomenc.c to assume that unused entries in the output arrays of AV1E_GET_SEQ_LEVEL_IDX and AV1E_GET_TARGET_SEQ_LEVEL_IDX are set to SEQ_LEVEL_MAX, then this behavior should be formally documented in source code comments and should be tested by test/level_test.cc.\n\nNOTE: There is a third possible solution. We can also require the users of AV1E_GET_SEQ_LEVEL_IDX and AV1E_GET_TARGET_SEQ_LEVEL_IDX to initialize the output arrays to all SEQ_LEVEL_MAX. Right now they initialize the output arrays to all 0 because it can be done with the simple initializer `\u003d { 0 }`.",
      "parentUuid": "a72787e6_78aed566",
      "revId": "b15360e9f4588a75146fe2e2f474033e3b6cd72e",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4e58cb74_f7f67e3e",
        "filename": "av1/encoder/level.c",
        "patchSetId": 3
      },
      "lineNbr": 1280,
      "author": {
        "id": 7525
      },
      "writtenOn": "2022-06-06T18:01:34Z",
      "side": 1,
      "message": "Thanks for the reply! I think option 1 makes sense, but since this is already used by people using ffmpeg, I fear that reverting the CL would mean that those who are experimenting with this would be caught by surprise, as ffmpeg patches tend to take a few weeks to finally merge. So how about we do this:\n\nFirst we add one more GET_NUM_OPERATING_POINTS API as you described, and submit a patch to ffmpeg to use that API to only check the proper number of levels. However we do not revert this CL as they are not really contradicting. In this way with or without the new patch, ffmpeg should work fine. \n\nAnd we also do 2 (extent get_seq_level_idx to set everything to SEQ_LEVEL_MAX), which will also not break how ffmpeg / aomenc is currently using these APIs. This is also better because even with get_num_operating_points, the clients could still send in an array that is larger than that size, and we can make sure they output a reasonable number.\n\nWhat do you think of this proposal?",
      "parentUuid": "96f162a8_d739f926",
      "revId": "b15360e9f4588a75146fe2e2f474033e3b6cd72e",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a7b667c2_c5c336ea",
        "filename": "av1/encoder/level.c",
        "patchSetId": 3
      },
      "lineNbr": 1280,
      "author": {
        "id": 9545
      },
      "writtenOn": "2022-06-06T23:08:22Z",
      "side": 1,
      "message": "Hi Bohan,\n\nSince this CL was committed recently (on May 25) and has not appeared in any libaom release, it should be fine to revert it. But I am not familiar with the ffmpeg development process, so I defer to your judgment.\n\nAlso, we can first modify ffmpeg/libavcodec/libaomenc.c to initialize the \n`levels` and `target_levels` arrays to all 31 instead of all 0:\n\n```\ndiff --git a/libavcodec/libaomenc.c b/libavcodec/libaomenc.c\nindex 7865ae161f..6c3308f2a7 100644\n--- a/libavcodec/libaomenc.c\n+++ b/libavcodec/libaomenc.c\n@@ -367,8 +367,12 @@ static av_cold int aom_free(AVCodecContext *avctx)\n #if defined(AOM_CTRL_AV1E_GET_SEQ_LEVEL_IDX) \u0026\u0026 \\\n     defined(AOM_CTRL_AV1E_GET_TARGET_SEQ_LEVEL_IDX)\n     if (!(avctx-\u003eflags \u0026 AV_CODEC_FLAG_PASS1)) {\n-        int levels[32] \u003d { 0 };\n-        int target_levels[32] \u003d { 0 };\n+        int levels[32];\n+        int target_levels[32];\n+        for (int i \u003d 0; i \u003c 32; i++) {\n+            levels[i] \u003d 31;\n+            target_levels[i] \u003d 31;\n+        }\n \n         if (!codecctl_intp(avctx, AV1E_GET_SEQ_LEVEL_IDX, levels) \u0026\u0026\n             !codecctl_intp(avctx, AV1E_GET_TARGET_SEQ_LEVEL_IDX,\n```\n\nThis allows ffmpeg/libavcodec/libaomenc.c to work with versions of libaom without this CL. Then we can revert this CL and add AV1E_GET_NUM_OPERATING_POINTS in either order.\n\nNote: I am writing a CL to add AV1E_GET_NUM_OPERATING_POINTS, but I won\u0027t revert this CL.",
      "parentUuid": "4e58cb74_f7f67e3e",
      "revId": "b15360e9f4588a75146fe2e2f474033e3b6cd72e",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    }
  ]
}