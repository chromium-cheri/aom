{
  "comments": [
    {
      "key": {
        "uuid": "50f84807_1cf1aa9f",
        "filename": "av1/common/daala_tx_kernels.h",
        "patchSetId": 3
      },
      "lineNbr": 39,
      "author": {
        "id": 7984
      },
      "writtenOn": "2018-01-02T11:16:10Z",
      "side": 1,
      "message": "I\u0027d just like to clarify on the status of the unbiased rounding operations od_rshift1(). Can you confirm if it is the intention to remove these operations and replace with fixed rounds of either (x+0)\u003e\u003e1 or (x+1)\u003e\u003e1 as discussed in the previous review? I ask as I think these are an issue for HW implementation in that they introduce latency where the full sign needs to be resolved before the round is known rather than just the parity (which is much easier to determine). (Note also that the IDCT4 synthesis Ola did was before the latest code restructure and so latency of that needs to be looked at again - but I think it generally helps to reduce the shift latency).",
      "revId": "84c8b2c130ae0407a42ab6520f63134ab24da7c9",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6a4f0aac_a9aa5692",
        "filename": "av1/common/daala_tx_kernels.h",
        "patchSetId": 3
      },
      "lineNbr": 92,
      "author": {
        "id": 7984
      },
      "writtenOn": "2018-01-02T11:16:10Z",
      "side": 1,
      "message": "I\u0027d just like to ask about the number of possible shift values q0,q1,q2 that would need to be supported by hw here. Atti from Google pointed out that the range seems to be 10-15 and so 6 different shifts. As mentioned in a previous mail it would be useful to understand which different shifts are actually required to prevent 32 bit overflow and which are just lower shifts since the coefficient happened to be even. Is it possible for you to describe what the shift limits are to prevent 32-bit overflow? The reason for the question is that the hw cost goes up as number of shifts increases.",
      "revId": "84c8b2c130ae0407a42ab6520f63134ab24da7c9",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9b9eb6f5_19e9e4bc",
        "filename": "av1/common/daala_tx_kernels.h",
        "patchSetId": 3
      },
      "lineNbr": 114,
      "author": {
        "id": 7984
      },
      "writtenOn": "2018-01-02T11:16:10Z",
      "side": 1,
      "message": "Can you confirm that \"v\" is always \"p0h\"? I\u0027m just wondering since it is named \"v\" rather than \"p0h\" whether you intend a more general operation than one just between p0/p0h and p1.",
      "revId": "84c8b2c130ae0407a42ab6520f63134ab24da7c9",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": true
    }
  ]
}