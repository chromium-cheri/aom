{
  "comments": [
    {
      "key": {
        "uuid": "50f84807_1cf1aa9f",
        "filename": "av1/common/daala_tx_kernels.h",
        "patchSetId": 3
      },
      "lineNbr": 39,
      "author": {
        "id": 7984
      },
      "writtenOn": "2018-01-02T11:16:10Z",
      "side": 1,
      "message": "I\u0027d just like to clarify on the status of the unbiased rounding operations od_rshift1(). Can you confirm if it is the intention to remove these operations and replace with fixed rounds of either (x+0)\u003e\u003e1 or (x+1)\u003e\u003e1 as discussed in the previous review? I ask as I think these are an issue for HW implementation in that they introduce latency where the full sign needs to be resolved before the round is known rather than just the parity (which is much easier to determine). (Note also that the IDCT4 synthesis Ola did was before the latest code restructure and so latency of that needs to be looked at again - but I think it generally helps to reduce the shift latency).",
      "revId": "84c8b2c130ae0407a42ab6520f63134ab24da7c9",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "32aa0b38_2bce32dc",
        "filename": "av1/common/daala_tx_kernels.h",
        "patchSetId": 3
      },
      "lineNbr": 39,
      "author": {
        "id": 5046
      },
      "writtenOn": "2018-01-03T20:18:29Z",
      "side": 1,
      "message": "Yes, we would also like to replace these unbiased shifts with rounds of either (x+0)\u003e\u003e1 or (x+1)\u003e\u003e1 as we previously discussed.  I did some simple tests trying the most obvious thing (either always add 0 or always add 1) and found that for small transforms sized 16-point or below, the biasing introduced was not that large.  However, for the 32-point and 64-point transforms it becomes quite significant and the IEEE-1180 tests fail.  Have you seen this in your testing?\n\nWe could try permutations of (x+0) and (x+1) among all of the different shifts to see some combination gives the minimal impact on transform accuracy.  I believe this is what you had suggested when you looked at the 4-point transform.  However, the dimensionality of the problem goes up pretty quickly, particularly when you include rect_tx and rect_tx_ext.\n\nI am open to suggestions on the best way to address this.",
      "parentUuid": "50f84807_1cf1aa9f",
      "revId": "84c8b2c130ae0407a42ab6520f63134ab24da7c9",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6a4f0aac_a9aa5692",
        "filename": "av1/common/daala_tx_kernels.h",
        "patchSetId": 3
      },
      "lineNbr": 92,
      "author": {
        "id": 7984
      },
      "writtenOn": "2018-01-02T11:16:10Z",
      "side": 1,
      "message": "I\u0027d just like to ask about the number of possible shift values q0,q1,q2 that would need to be supported by hw here. Atti from Google pointed out that the range seems to be 10-15 and so 6 different shifts. As mentioned in a previous mail it would be useful to understand which different shifts are actually required to prevent 32 bit overflow and which are just lower shifts since the coefficient happened to be even. Is it possible for you to describe what the shift limits are to prevent 32-bit overflow? The reason for the question is that the hw cost goes up as number of shifts increases.",
      "revId": "84c8b2c130ae0407a42ab6520f63134ab24da7c9",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "841f5644_044f61c0",
        "filename": "av1/common/daala_tx_kernels.h",
        "patchSetId": 3
      },
      "lineNbr": 92,
      "author": {
        "id": 5046
      },
      "writtenOn": "2018-01-03T20:18:29Z",
      "side": 1,
      "message": "The tool that generates these shifts keeps track of the number of bits needed for the constant v. the reduction in bits necessary to keep the multiplication in range.  The tables in\n\nhttps://github.com/negge/tx_fun/blob/master/src/tx_const.c\n\nwhich end in _FLAT contain both the \u0027shift\u0027 value used for the multiplication constant (which is the value that makes the constant odd) and the \u0027max_shift\u0027 value which is the largest possible shift you can use that keeps the multiplication operation from overflowing.\n\nAn example might make this easier to understand.  Consider the constants in the TX_FDSTIV_2_ASYM_FLAT_MULTS[3] table:\n\ntx_mult TX_FDSTIV_2_ASYM_FLAT_MULTS[3] \u003d {\n  {  0.92387953251128673848313610506011,    473,  9, 13 },\n  {  0.76536686473017956355846536098397,   3135, 12, 14 },\n  {  0.54119610014619701221505465582595,   4433, 13, 13 },\n};\n\nThe constant for 0.92387953251128673848313610506011 could be represented as 15137 in Q14, because 0.92387953251128673848313610506011*2^15 \u003d 30273.68452... which rounds to 30274, an even value.  However, it needed to be reduced from Q15 to Q13 so that the product fit in 32-bits.  But 0.92387953251128673848313610506011*2^13 \u003d 7568.42113... which rounds to 7568 (another even value) so instead the Q9 value 473 is used since 7568 is divisible by 16.\n\nWe intentionally used odd values with smaller shifts thinking that having a smaller multiplier would be helpful to hardware.  However, you could always use the larger even constant if having a few small variations in the constants is helpful.\n\nBased the current tables in tx_const.c, there are only 4 values for max_shift: 15, 14, 13 and 12.",
      "parentUuid": "6a4f0aac_a9aa5692",
      "revId": "84c8b2c130ae0407a42ab6520f63134ab24da7c9",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9b9eb6f5_19e9e4bc",
        "filename": "av1/common/daala_tx_kernels.h",
        "patchSetId": 3
      },
      "lineNbr": 114,
      "author": {
        "id": 7984
      },
      "writtenOn": "2018-01-02T11:16:10Z",
      "side": 1,
      "message": "Can you confirm that \"v\" is always \"p0h\"? I\u0027m just wondering since it is named \"v\" rather than \"p0h\" whether you intend a more general operation than one just between p0/p0h and p1.",
      "revId": "84c8b2c130ae0407a42ab6520f63134ab24da7c9",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e509452a_d1794feb",
        "filename": "av1/common/daala_tx_kernels.h",
        "patchSetId": 3
      },
      "lineNbr": 114,
      "author": {
        "id": 5046
      },
      "writtenOn": "2018-01-03T20:18:29Z",
      "side": 1,
      "message": "Yes, I can confirm that it is always p0h.  I can update the source code to reflect this.",
      "parentUuid": "9b9eb6f5_19e9e4bc",
      "revId": "84c8b2c130ae0407a42ab6520f63134ab24da7c9",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": true
    }
  ]
}