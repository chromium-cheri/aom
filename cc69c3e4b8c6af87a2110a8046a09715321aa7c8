{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "3243a532_8abe8100",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 9545
      },
      "writtenOn": "2022-12-05T20:53:59Z",
      "side": 1,
      "message": "LGTM.",
      "revId": "cc69c3e4b8c6af87a2110a8046a09715321aa7c8",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a37d7180_c79785d8",
        "filename": "av1/common/x86/jnt_convolve_avx2.c",
        "patchSetId": 1
      },
      "lineNbr": 1054,
      "author": {
        "id": 9545
      },
      "writtenOn": "2022-12-05T20:53:59Z",
      "side": 1,
      "message": "Optional: I remember libaom has functions for unaligned loads. I just searched for them. They may be the loadu_intxx functions in aom_dsp/x86/mem_sse2:\n\n```\nstatic INLINE int16_t loadu_int16(const void *src) {\n  int16_t v;\n  memcpy(\u0026v, src, sizeof(v));\n  return v;\n}\n\nstatic INLINE int32_t loadu_int32(const void *src) {\n  int32_t v;\n  memcpy(\u0026v, src, sizeof(v));\n  return v;\n}\n\nstatic INLINE int64_t loadu_int64(const void *src) {\n  int64_t v;\n  memcpy(\u0026v, src, sizeof(v));\n  return v;\n}\n```\n\nJames, do you remember?",
      "revId": "cc69c3e4b8c6af87a2110a8046a09715321aa7c8",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    }
  ]
}