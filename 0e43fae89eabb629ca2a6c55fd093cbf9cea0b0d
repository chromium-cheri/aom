{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "38d51449_44865bc0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 9611
      },
      "writtenOn": "2021-02-10T06:23:08Z",
      "side": 1,
      "message": "Hi Wan-Teh,\n\nPlease review.",
      "revId": "0e43fae89eabb629ca2a6c55fd093cbf9cea0b0d",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "506263f5_89d6b637",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 9545
      },
      "writtenOn": "2021-02-10T19:44:10Z",
      "side": 1,
      "message": "Jingning: PTAL. Thanks!",
      "revId": "0e43fae89eabb629ca2a6c55fd093cbf9cea0b0d",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ab680ec1_55816618",
        "filename": "av1/av1_cx_iface.c",
        "patchSetId": 9
      },
      "lineNbr": 2145,
      "author": {
        "id": 9545
      },
      "writtenOn": "2021-02-11T06:38:09Z",
      "side": 1,
      "message": "Venkata: I chatted with Jingning more. He said that even lag_in_frames cannot be used as a reliable signal to decide the max number of successive no-show frames.\n\nMaybe we can use a conservative change first:\n\n  int max_pending_frames \u003d 8;\n  if (cpi-\u003eoxcf.input_cfg.limit !\u003d 0)\n    max_pending_frames \u003d AOMMIN(max_pending_frames, cpi-\u003eoxcf.input_cfg.limit);\n  size_t data_sz \u003d frame_sz * max_pending_frames;\n\nI will take a look at how hard it is to dynamically grow the buffer size. It does not seem very easy.",
      "range": {
        "startLine": 2145,
        "startChar": 54,
        "endLine": 2145,
        "endChar": 67
      },
      "revId": "0e43fae89eabb629ca2a6c55fd093cbf9cea0b0d",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e7a18819_190ed186",
        "filename": "av1/av1_cx_iface.c",
        "patchSetId": 9
      },
      "lineNbr": 2145,
      "author": {
        "id": 5022
      },
      "writtenOn": "2021-02-12T23:23:14Z",
      "side": 1,
      "message": "The use of ARF is not necessarily dependent on the lag-in-frame numbers. The ARF can potentially be synthesized using previously coded source frames as a no-show reference frame.\n\nThat said, the spec allows the use of ARF even without look ahead buffer.",
      "parentUuid": "ab680ec1_55816618",
      "range": {
        "startLine": 2145,
        "startChar": 54,
        "endLine": 2145,
        "endChar": 67
      },
      "revId": "0e43fae89eabb629ca2a6c55fd093cbf9cea0b0d",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "039a33ab_bf587aca",
        "filename": "av1/av1_cx_iface.c",
        "patchSetId": 9
      },
      "lineNbr": 2145,
      "author": {
        "id": 9611
      },
      "writtenOn": "2021-02-15T15:24:39Z",
      "side": 1,
      "message": "Hi Jingning and Wan-Teh,\n\nPlease find our understanding/options below for the optimization.\n1) In vp9 encoder, the allocation size is calculated as mentioned below.\n   data_sz \u003d ctx-\u003ecfg.g_w * ctx-\u003ecfg.g_h * get_image_bps(img) / 8 *\n         (cpi-\u003emulti_layer_arf ? 8 : 2);\n\n\nAs per our understanding, when multi_layer_arf\u003d0, the buffer size should have been 4 * frame_size. But it seemed to use 2 * frame_size (corresponding to one non-show frame + one show frame). We proposed similar approach in current patch set, based on above understanding.\nNow, we understand the worst case scenario as per the standard though the current encoder code does not support the same.\n\n2) From the recent changes added to support ALLINTRA mode in libaom, the change can be modified as below.\n   int max_pending_frames \u003d 8;\n   If ((cpi-\u003eoxcf.mode \u003d\u003d ALLINTRA \u0026\u0026 !cpi-\u003eoxcf.kf_cfg.fwd_kf_enabled) || \n                          (cpi-\u003eoxcf.gf_cfg.enable_auto_arf\u003d\u003d0))\n          max_pending_frames \u003d 1;\n   size_t data_sz \u003d frame_sz * max_pending_frames;\n\n\nAs per our understanding, when encoding mode is ALLINTRA with fwd_kf_enabled\u003d1, there can be no-show frames(as per the standard). Hence, the first part of the condition takes care of populating max_pending_frames accordingly (assuming libavif sets encoding mode as AOM_USAGE_ALL_INTRA).\nThis optimization is applicable when enable_auto_arf\u003d0 as well, as no-show frames will be absent in this case.\n\n3) Following is the approach given by you in one of your earlier messages.\n   int max_pending_frames \u003d 8; \n   if (cpi-\u003eoxcf.input_cfg.limit !\u003d 0) \n      max_pending_frames \u003d AOMMIN(max_pending_frames,cpi-\u003eoxcf.input_cfg.limit); \n   size_t data_sz \u003d frame_sz * max_pending_frames;\n\nWe are planning to follow the approach as in (2) as this can help low-delay encode as well (assuming –auto-alt-ref\u003d0). Please let us know in case (3) preferred over (2).\n\nRegards,\nVenkata.",
      "revId": "0e43fae89eabb629ca2a6c55fd093cbf9cea0b0d",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f46cd93d_448b3ef5",
        "filename": "av1/av1_cx_iface.c",
        "patchSetId": 9
      },
      "lineNbr": 2145,
      "author": {
        "id": 9545
      },
      "writtenOn": "2021-02-18T06:00:24Z",
      "side": 1,
      "message": "Hi Venkata,\n\nThank you for your comments. Please go ahead and implement (2) in this CL. I tried to verify the correctness of (2) using Code Search, but it is still difficult to show why !cpi-\u003eoxcf.kf_cfg.fwd_kf_enabled or cpi-\u003eoxcf.gf_cfg.enable_auto_arf\u003d\u003d0 implies all frames will be visible (show) frames.\n\nI wrote a prototype of the dynamic buffer approach in https://aomedia-review.googlesource.com/c/aom/+/130406. Please take a look and play with it. I think the dynamic buffer approach will be easier to understand and can potentially use less memory, at the cost of extra realloc() calls. The tricky part is to figure out the worst-case cx_data_size value before the av1_get_compressed_data() call.",
      "parentUuid": "039a33ab_bf587aca",
      "revId": "0e43fae89eabb629ca2a6c55fd093cbf9cea0b0d",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "694abc66_ff9070d8",
        "filename": "av1/av1_cx_iface.c",
        "patchSetId": 9
      },
      "lineNbr": 2145,
      "author": {
        "id": 9611
      },
      "writtenOn": "2021-02-18T15:47:12Z",
      "side": 1,
      "message": "Hi Wan-Teh,\n\nIn this patch, we made modifications to optimize the allocation of bit-stream buffer using approach 2.\n\nPlease check the following variables to track the population of show_frame flag\nuse_arf_in_this_kf_group -\u003e use_alt_ref -\u003e max_layer_depth_allowed -\u003e gf_group-\u003eupdate_type(ARF_UPDATE)/frame_type -\u003e frame_params.show_frame\n\nWe validated the current patch for video and still-image encode. Specifically, we configured libaom in ALLINTRA mode (in libavif) for AVIF encode. \nFollowing are memory reduction results when AVIF encode was tested for ‘building.jpg’ (4032x3024) image at cq_level\u003d18.\n\n   Speed                 HEAP Memory\n   preset                Reduction(%)\n     6          ~23.7 (from 518.3 MB to 395.2 MB)\n\n \n\nAs this change is also applicable ‘real-time’ (with –auto-alt-ref\u003d0) configuration, we have measured the memory reduction for a 1280x720 content.\n\n   Encoding           Speed                 HEAP Memory\n   Configuration      preset                Reduction(%)\n     RT                7           ~14.8 (from 63.66 MB to 54.21 MB)\n\n\nWe thought of the dynamic approach for allocating the stream buffer earlier, but did not pursue the same as it might involve allocations during run-time depending on the number of no-show frames. While encoding a video with --lag-in-frames\u003d35, there might be up to 5 additional realloc() over the complete video. Hence we tried picking the approach as suited for image encode, at the same time optimizing for video encode (though not dynamic).\n\nPlease let us know how we can take forward the optimization.\n\nRegards,\nvenkata.",
      "parentUuid": "f46cd93d_448b3ef5",
      "revId": "0e43fae89eabb629ca2a6c55fd093cbf9cea0b0d",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "076a8e02_43b872c0",
        "filename": "av1/av1_cx_iface.c",
        "patchSetId": 9
      },
      "lineNbr": 2145,
      "author": {
        "id": 9545
      },
      "writtenOn": "2021-02-19T03:29:22Z",
      "side": 1,
      "message": "Hi Venkata,\n\nMy dynamic buffer prototye https://aomedia-review.googlesource.com/c/aom/+/130406 prints diagnostic messages, so you can try it and see how many realloc() calls are actually called. When I run test_libaom, I see two worst-case frame sizes are large enough to hold 4 to 5 frames. So the number of realloc() calls is small and it should consume less memory in practice.\n\nWe can easily change the prototype to do at most one realloc() by growing from one worst-case frame size to 8 worst-case frame sizes directly.",
      "parentUuid": "694abc66_ff9070d8",
      "revId": "0e43fae89eabb629ca2a6c55fd093cbf9cea0b0d",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c5bbb67d_50f6845f",
        "filename": "av1/av1_cx_iface.c",
        "patchSetId": 9
      },
      "lineNbr": 2145,
      "author": {
        "id": 9611
      },
      "writtenOn": "2021-02-19T04:05:46Z",
      "side": 1,
      "message": "Hi Wan-teh,\n\nIn our message, 4-5 realloc() calls is based on the worst case number of no-show frames. This can happen at higher bit-rates depending on the complexity of the content. When we tested for higher bit-rates, we were seeing up to 3 calls. Hence we accept that it should consume less memory than static allocation for video encode.",
      "parentUuid": "076a8e02_43b872c0",
      "revId": "0e43fae89eabb629ca2a6c55fd093cbf9cea0b0d",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "73ae2d57_272ae35b",
        "filename": "av1/av1_cx_iface.c",
        "patchSetId": 9
      },
      "lineNbr": 2151,
      "author": {
        "id": 9545
      },
      "writtenOn": "2021-02-11T01:40:50Z",
      "side": 1,
      "message": "Venkata: I discussed this CL with Jingning. He suggested that we replace\n\n    ctx-\u003ecpi-\u003eoxcf.gf_cfg.gf_max_pyr_height + 1\n\nwith 8 (which is the maximum number of reference frames in AV1). He said in principle one can use more than gf_max_pyr_height. Maybe it\u0027s not a good idea for typical compression performance but it does exist.\n\nI have a question: if SVC is enabled, do we need to consider the number of spatial layers?\n\nI know you aim for a general solution that will benefit not only image encoding but also RTC and all keyframe video encoding. But I suggest we use a conservative, partial solution first.\n\nAlso, it may be better to pursue a dynamic approach (in a separate CL). Instead of estimating the maximum bitstream buffer size, we can start with a small size, say one frame, and grow the buffer when it is too small.",
      "range": {
        "startLine": 2151,
        "startChar": 23,
        "endLine": 2151,
        "endChar": 66
      },
      "revId": "0e43fae89eabb629ca2a6c55fd093cbf9cea0b0d",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    }
  ]
}