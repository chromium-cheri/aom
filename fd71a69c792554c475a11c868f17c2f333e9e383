{
  "comments": [
    {
      "key": {
        "uuid": "93b96beb_7089ab1f",
        "filename": "av1/decoder/obu.c",
        "patchSetId": 4
      },
      "lineNbr": 546,
      "author": {
        "id": 5005
      },
      "writtenOn": "2019-06-06T15:55:27Z",
      "side": 1,
      "message": "Are we just checking sz \u003d\u003d 0 here?",
      "range": {
        "startLine": 546,
        "startChar": 6,
        "endLine": 546,
        "endChar": 13
      },
      "revId": "fd71a69c792554c475a11c868f17c2f333e9e383",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9a5575ac_543006bb",
        "filename": "av1/decoder/obu.c",
        "patchSetId": 4
      },
      "lineNbr": 546,
      "author": {
        "id": 9545
      },
      "writtenOn": "2019-06-06T16:25:50Z",
      "side": 1,
      "message": "The two alternative checks you suggested would also work. The checks I use here are a systematic way to avoid buffer overflows in parsing code. The checks follow a simple principle: before each access to the buffer, we check if the largest buffer index we\u0027re about to use is less than the buffer size. If that index is \u003e\u003d the buffer size, then we return an error.\n\nHere, we are about to read data[i] at line 550, so we check if the largest index of that read (i) is less than the buffer size (sz), and return an error otherwise.",
      "parentUuid": "93b96beb_7089ab1f",
      "range": {
        "startLine": 546,
        "startChar": 6,
        "endLine": 546,
        "endChar": 13
      },
      "revId": "fd71a69c792554c475a11c868f17c2f333e9e383",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e075c6bc_3279e1ff",
        "filename": "av1/decoder/obu.c",
        "patchSetId": 4
      },
      "lineNbr": 554,
      "author": {
        "id": 5005
      },
      "writtenOn": "2019-06-06T15:55:27Z",
      "side": 1,
      "message": "sz \u003d\u003d 1?",
      "range": {
        "startLine": 554,
        "startChar": 8,
        "endLine": 554,
        "endChar": 15
      },
      "revId": "fd71a69c792554c475a11c868f17c2f333e9e383",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "98d277a9_9bfe6a6c",
        "filename": "av1/decoder/obu.c",
        "patchSetId": 4
      },
      "lineNbr": 554,
      "author": {
        "id": 9545
      },
      "writtenOn": "2019-06-06T16:25:50Z",
      "side": 1,
      "message": "Similarly, here we are about to read one more byte at index i (although we don\u0027t actually read it; we skip over it), so again we check if i \u003c sz, and return an error otherwise.",
      "parentUuid": "e075c6bc_3279e1ff",
      "range": {
        "startLine": 554,
        "startChar": 8,
        "endLine": 554,
        "endChar": 15
      },
      "revId": "fd71a69c792554c475a11c868f17c2f333e9e383",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    }
  ]
}