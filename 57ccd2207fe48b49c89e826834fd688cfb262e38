{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "bc24a2e0_206097e5",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 9545
      },
      "writtenOn": "2023-08-17T18:26:00Z",
      "side": 1,
      "message": "LGTM.",
      "revId": "57ccd2207fe48b49c89e826834fd688cfb262e38",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "76aa2d35_19f6049f",
        "filename": "av1/encoder/mcomp.c",
        "patchSetId": 6
      },
      "lineNbr": 2148,
      "author": {
        "id": 9545
      },
      "writtenOn": "2023-08-17T18:26:00Z",
      "side": 1,
      "message": "When these aom_malloc() calls fail, CHECK_MEM_ERROR calls aom_internal_error(), which does a long jump out of this function. So we will leak memory when the second or later aom_malloc() call fails.\n\nYou don\u0027t need to address this issue in this CL. The solution requires rewriting these lines of code without using the CHECK_MEM_ERROR macro, something like this:\n\n```\n  int16_t *hbuf \u003d (int16_t *)aom_malloc(search_width * sizeof(*hbuf));\n  ...\n  int16_t *src_vbuf \u003d (int16_t *)aom_malloc(bh * sizeof(*src_vbuf));\n  if (!hbuf || !vbuf || !src_hbuf || !src_vbuf) {\n    aom_free(hbuf);\n    ...\n    aom_free(src_vbuf);\n    aom_internal_error(...);\n  }\n```",
      "revId": "57ccd2207fe48b49c89e826834fd688cfb262e38",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    }
  ]
}