{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "a760d73b_0f2b089b",
        "filename": "av1/av1_cx_iface.c",
        "patchSetId": 1
      },
      "lineNbr": 1509,
      "author": {
        "id": 5020
      },
      "writtenOn": "2023-10-06T17:01:56Z",
      "side": 1,
      "message": "can this just be stored in aom_codec_alg_priv?",
      "range": {
        "startLine": 1509,
        "startChar": 21,
        "endLine": 1509,
        "endChar": 39
      },
      "revId": "850bc0fd10e84e4b4853813145a8a6223679d7a9",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dcbbc3d2_4a7cd512",
        "filename": "av1/av1_cx_iface.c",
        "patchSetId": 1
      },
      "lineNbr": 1509,
      "author": {
        "id": 9545
      },
      "writtenOn": "2023-10-06T19:52:57Z",
      "side": 1,
      "message": "Marco: It doesn\u0027t seem necessary to add `monochrome_on_init`. It seems that we can just test `ctx-\u003ecfg.monochrome \u0026\u0026 !cfg-\u003emonochrome`.",
      "revId": "850bc0fd10e84e4b4853813145a8a6223679d7a9",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "855c1618_9ecb4c2b",
        "filename": "av1/av1_cx_iface.c",
        "patchSetId": 1
      },
      "lineNbr": 1510,
      "author": {
        "id": 5020
      },
      "writtenOn": "2023-10-06T17:01:56Z",
      "side": 1,
      "message": "This could get a TODO comment since I don\u0027t see it being impossible to switch if going in the other direction works, though that\u0027s easier given the allocations.",
      "revId": "850bc0fd10e84e4b4853813145a8a6223679d7a9",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c8bd2319_d467d7f1",
        "filename": "test/film_grain_table_test.cc",
        "patchSetId": 1
      },
      "lineNbr": 328,
      "author": {
        "id": 9545
      },
      "writtenOn": "2023-10-06T19:52:57Z",
      "side": 1,
      "message": "We should add a test that verifies the crash has been fixed.",
      "revId": "850bc0fd10e84e4b4853813145a8a6223679d7a9",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8f36bdca_ea9d3c6f",
        "filename": "test/film_grain_table_test.cc",
        "patchSetId": 1
      },
      "lineNbr": 332,
      "author": {
        "id": 5020
      },
      "writtenOn": "2023-10-06T17:01:56Z",
      "side": 1,
      "message": "in this case you could expect a fatal failure. That way if the behavior changes the test will fail. It\u0027s easy to miss updating a GTEST_SKIP when making a fix.",
      "revId": "850bc0fd10e84e4b4853813145a8a6223679d7a9",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "787a712b_5a21ef97",
        "filename": "test/film_grain_table_test.cc",
        "patchSetId": 1
      },
      "lineNbr": 332,
      "author": {
        "id": 5960
      },
      "writtenOn": "2023-10-06T19:13:26Z",
      "side": 1,
      "message": "I think the best way is to propagate the error code in RunLoop so we can check the error code \u0026 the message to match what is expected. Of course that\u0027s beyond this CL\u0027s scope.",
      "parentUuid": "8f36bdca_ea9d3c6f",
      "revId": "850bc0fd10e84e4b4853813145a8a6223679d7a9",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7479e886_d3199845",
        "filename": "test/film_grain_table_test.cc",
        "patchSetId": 1
      },
      "lineNbr": 332,
      "author": {
        "id": 5020
      },
      "writtenOn": "2023-10-06T19:24:33Z",
      "side": 1,
      "message": "\u003e I think the best way is to propagate the error code in RunLoop so we can check the error code \u0026 the message to match what is expected. Of course that\u0027s beyond this CL\u0027s scope.\n\nWhat I was suggesting was to change the ASSERT_NO_FATAL_FAILURES in that case and add a checking expecting a failure.",
      "parentUuid": "787a712b_5a21ef97",
      "revId": "850bc0fd10e84e4b4853813145a8a6223679d7a9",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f16ae125_49f28fbb",
        "filename": "test/film_grain_table_test.cc",
        "patchSetId": 1
      },
      "lineNbr": 332,
      "author": {
        "id": 5960
      },
      "writtenOn": "2023-10-06T19:32:13Z",
      "side": 1,
      "message": "That works for this CL and for this particular case.\n\nWhat I suggested is just inspired by this CL as we don\u0027t have many tests expecting the encoder to fail.\nIt\u0027s not against what you suggested for this CL but that would benefit other tests and potentially new tests. If `RunLoop()` (and other functions within `encode_test_driver.h`) returns the error code / message we can check it more precisely against what kind of error the test is expecting, instead of just fatal or no failure.",
      "parentUuid": "7479e886_d3199845",
      "revId": "850bc0fd10e84e4b4853813145a8a6223679d7a9",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    }
  ]
}