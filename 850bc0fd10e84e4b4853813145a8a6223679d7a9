{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "a760d73b_0f2b089b",
        "filename": "av1/av1_cx_iface.c",
        "patchSetId": 1
      },
      "lineNbr": 1509,
      "author": {
        "id": 5020
      },
      "writtenOn": "2023-10-06T17:01:56Z",
      "side": 1,
      "message": "can this just be stored in aom_codec_alg_priv?",
      "range": {
        "startLine": 1509,
        "startChar": 21,
        "endLine": 1509,
        "endChar": 39
      },
      "revId": "850bc0fd10e84e4b4853813145a8a6223679d7a9",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dcbbc3d2_4a7cd512",
        "filename": "av1/av1_cx_iface.c",
        "patchSetId": 1
      },
      "lineNbr": 1509,
      "author": {
        "id": 9545
      },
      "writtenOn": "2023-10-06T19:52:57Z",
      "side": 1,
      "message": "Marco: It doesn\u0027t seem necessary to add `monochrome_on_init`. It seems that we can just test `ctx-\u003ecfg.monochrome \u0026\u0026 !cfg-\u003emonochrome`.",
      "revId": "850bc0fd10e84e4b4853813145a8a6223679d7a9",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "63e3445e_2eb4118e",
        "filename": "av1/av1_cx_iface.c",
        "patchSetId": 1
      },
      "lineNbr": 1509,
      "author": {
        "id": 9545
      },
      "writtenOn": "2023-10-06T21:01:43Z",
      "side": 1,
      "message": "My suggestion is incorrect. The alternative test I suggested will block any change of monochrome from 1 to 0, so it will make mode 2 (monochrome 0, 1, 0) fail.",
      "parentUuid": "dcbbc3d2_4a7cd512",
      "revId": "850bc0fd10e84e4b4853813145a8a6223679d7a9",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "593d24fe_6d5cced6",
        "filename": "av1/av1_cx_iface.c",
        "patchSetId": 1
      },
      "lineNbr": 1509,
      "author": {
        "id": 5190
      },
      "writtenOn": "2023-10-06T23:46:21Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "a760d73b_0f2b089b",
      "range": {
        "startLine": 1509,
        "startChar": 21,
        "endLine": 1509,
        "endChar": 39
      },
      "revId": "850bc0fd10e84e4b4853813145a8a6223679d7a9",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "855c1618_9ecb4c2b",
        "filename": "av1/av1_cx_iface.c",
        "patchSetId": 1
      },
      "lineNbr": 1510,
      "author": {
        "id": 5020
      },
      "writtenOn": "2023-10-06T17:01:56Z",
      "side": 1,
      "message": "This could get a TODO comment since I don\u0027t see it being impossible to switch if going in the other direction works, though that\u0027s easier given the allocations.",
      "revId": "850bc0fd10e84e4b4853813145a8a6223679d7a9",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "60e492f9_915e5488",
        "filename": "av1/av1_cx_iface.c",
        "patchSetId": 1
      },
      "lineNbr": 1510,
      "author": {
        "id": 5190
      },
      "writtenOn": "2023-10-06T23:46:21Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "855c1618_9ecb4c2b",
      "revId": "850bc0fd10e84e4b4853813145a8a6223679d7a9",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c8bd2319_d467d7f1",
        "filename": "test/film_grain_table_test.cc",
        "patchSetId": 1
      },
      "lineNbr": 328,
      "author": {
        "id": 9545
      },
      "writtenOn": "2023-10-06T19:52:57Z",
      "side": 1,
      "message": "We should add a test that verifies the crash has been fixed.",
      "revId": "850bc0fd10e84e4b4853813145a8a6223679d7a9",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8f36bdca_ea9d3c6f",
        "filename": "test/film_grain_table_test.cc",
        "patchSetId": 1
      },
      "lineNbr": 332,
      "author": {
        "id": 5020
      },
      "writtenOn": "2023-10-06T17:01:56Z",
      "side": 1,
      "message": "in this case you could expect a fatal failure. That way if the behavior changes the test will fail. It\u0027s easy to miss updating a GTEST_SKIP when making a fix.",
      "revId": "850bc0fd10e84e4b4853813145a8a6223679d7a9",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "787a712b_5a21ef97",
        "filename": "test/film_grain_table_test.cc",
        "patchSetId": 1
      },
      "lineNbr": 332,
      "author": {
        "id": 5960
      },
      "writtenOn": "2023-10-06T19:13:26Z",
      "side": 1,
      "message": "I think the best way is to propagate the error code in RunLoop so we can check the error code \u0026 the message to match what is expected. Of course that\u0027s beyond this CL\u0027s scope.",
      "parentUuid": "8f36bdca_ea9d3c6f",
      "revId": "850bc0fd10e84e4b4853813145a8a6223679d7a9",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7479e886_d3199845",
        "filename": "test/film_grain_table_test.cc",
        "patchSetId": 1
      },
      "lineNbr": 332,
      "author": {
        "id": 5020
      },
      "writtenOn": "2023-10-06T19:24:33Z",
      "side": 1,
      "message": "\u003e I think the best way is to propagate the error code in RunLoop so we can check the error code \u0026 the message to match what is expected. Of course that\u0027s beyond this CL\u0027s scope.\n\nWhat I was suggesting was to change the ASSERT_NO_FATAL_FAILURES in that case and add a checking expecting a failure.",
      "parentUuid": "787a712b_5a21ef97",
      "revId": "850bc0fd10e84e4b4853813145a8a6223679d7a9",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f16ae125_49f28fbb",
        "filename": "test/film_grain_table_test.cc",
        "patchSetId": 1
      },
      "lineNbr": 332,
      "author": {
        "id": 5960
      },
      "writtenOn": "2023-10-06T19:32:13Z",
      "side": 1,
      "message": "That works for this CL and for this particular case.\n\nWhat I suggested is just inspired by this CL as we don\u0027t have many tests expecting the encoder to fail.\nIt\u0027s not against what you suggested for this CL but that would benefit other tests and potentially new tests. If `RunLoop()` (and other functions within `encode_test_driver.h`) returns the error code / message we can check it more precisely against what kind of error the test is expecting, instead of just fatal or no failure.",
      "parentUuid": "7479e886_d3199845",
      "revId": "850bc0fd10e84e4b4853813145a8a6223679d7a9",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "03a67959_41c87952",
        "filename": "test/film_grain_table_test.cc",
        "patchSetId": 1
      },
      "lineNbr": 332,
      "author": {
        "id": 5190
      },
      "writtenOn": "2023-10-06T23:46:21Z",
      "side": 1,
      "message": "Don\u0027t see an ASSERT_FATAL_FAILURE or ASSERT_FAILURE option, so not sure what to use here.",
      "parentUuid": "f16ae125_49f28fbb",
      "revId": "850bc0fd10e84e4b4853813145a8a6223679d7a9",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e4088d2b_1ae4ccde",
        "filename": "test/film_grain_table_test.cc",
        "patchSetId": 1
      },
      "lineNbr": 332,
      "author": {
        "id": 5020
      },
      "writtenOn": "2023-10-07T00:03:03Z",
      "side": 1,
      "message": "\u003e Don\u0027t see an ASSERT_FATAL_FAILURE or ASSERT_FAILURE option, so not sure what to use here.\n\nAt first I was thinking a death test, but that\u0027s not quite right.\n\nhttps://google.github.io/googletest/advanced.html\n\nI think you can just call `RunLoop()`, ASSERT `HasFatalFailure()` and then override it with a SUCCESS call. Otherwise calling the encoder directly is an option rather than using the encoder driver framework.",
      "parentUuid": "03a67959_41c87952",
      "revId": "850bc0fd10e84e4b4853813145a8a6223679d7a9",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "287e4b4a_8812fc51",
        "filename": "test/film_grain_table_test.cc",
        "patchSetId": 1
      },
      "lineNbr": 332,
      "author": {
        "id": 5020
      },
      "writtenOn": "2023-10-07T01:52:19Z",
      "side": 1,
      "message": "\u003e \u003e Don\u0027t see an ASSERT_FATAL_FAILURE or ASSERT_FAILURE option, so not sure what to use here.\n\u003e \n\u003e At first I was thinking a death test, but that\u0027s not quite right.\n\u003e \n\u003e https://google.github.io/googletest/advanced.html\n\u003e \n\u003e I think you can just call `RunLoop()`, ASSERT `HasFatalFailure()` and then override it with a SUCCESS call. Otherwise calling the encoder directly is an option rather than using the encoder driver framework.\n\nThat should have been SUCCEEDED, but that won\u0027t reset failures, so you may need to check vpx_codec_encode directly.",
      "parentUuid": "e4088d2b_1ae4ccde",
      "revId": "850bc0fd10e84e4b4853813145a8a6223679d7a9",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f9c5c0ca_f6d0b624",
        "filename": "test/film_grain_table_test.cc",
        "patchSetId": 1
      },
      "lineNbr": 332,
      "author": {
        "id": 5020
      },
      "writtenOn": "2023-10-07T01:54:51Z",
      "side": 1,
      "message": "\u003e \u003e \u003e Don\u0027t see an ASSERT_FATAL_FAILURE or ASSERT_FAILURE option, so not sure what to use here.\n\u003e \u003e \n\u003e \u003e At first I was thinking a death test, but that\u0027s not quite right.\n\u003e \u003e \n\u003e \u003e https://google.github.io/googletest/advanced.html\n\u003e \u003e \n\u003e \u003e I think you can just call `RunLoop()`, ASSERT `HasFatalFailure()` and then override it with a SUCCESS call. Otherwise calling the encoder directly is an option rather than using the encoder driver framework.\n\u003e \n\u003e That should have been SUCCEEDED, but that won\u0027t reset failures, so you may need to check vpx_codec_encode directly.\n\nSUCCEED:\nhttp://google.github.io/googletest/reference/assertions.html#SUCCEED",
      "parentUuid": "287e4b4a_8812fc51",
      "revId": "850bc0fd10e84e4b4853813145a8a6223679d7a9",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    }
  ]
}