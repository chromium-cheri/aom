{
  "comments": [
    {
      "key": {
        "uuid": "239de5e8_3bdc9d79",
        "filename": "av1/av1_dx_iface.c",
        "patchSetId": 1
      },
      "lineNbr": 158,
      "author": {
        "id": 9545
      },
      "writtenOn": "2018-05-21T21:08:33Z",
      "side": 1,
      "message": "Optional: I suggest returning aom_codec_err_t. In fact, I would also suggest aom_get_num_layers_from_operating_point_idc return aom_codec_err_t, so that the caller does not need to speculate what the error is.",
      "range": {
        "startLine": 158,
        "startChar": 7,
        "endLine": 158,
        "endChar": 10
      },
      "revId": "15b279ec74bcb02465e1ed60805e73facc08b493",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f89732db_45fe6328",
        "filename": "av1/av1_dx_iface.c",
        "patchSetId": 1
      },
      "lineNbr": 253,
      "author": {
        "id": 9545
      },
      "writtenOn": "2018-05-21T21:08:33Z",
      "side": 1,
      "message": "I am not nit-picking; This error code is not accurate. The only reason parse_operating_points() can fail is that we pass a null pointer to aom_get_num_layers_from_operating_point_idc(). That is an internal error (a bug in our own code), not a corrupt frame. The closest error code I can find is AOM_CODEC_INVALID_PARAM or AOM_CODEC_ERROR.",
      "range": {
        "startLine": 253,
        "startChar": 11,
        "endLine": 253,
        "endChar": 34
      },
      "revId": "15b279ec74bcb02465e1ed60805e73facc08b493",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "03697599_12621969",
        "filename": "av1/decoder/obu.c",
        "patchSetId": 1
      },
      "lineNbr": 134,
      "author": {
        "id": 9545
      },
      "writtenOn": "2018-05-21T21:08:33Z",
      "side": 1,
      "message": "[This is just a question, not a request for change.] These two for loops calculate the \"population count\" (the number of 1 bits in an integer). Does libaom have a popcount function? I didn\u0027t find one.",
      "range": {
        "startLine": 128,
        "startChar": 0,
        "endLine": 134,
        "endChar": 5
      },
      "revId": "15b279ec74bcb02465e1ed60805e73facc08b493",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "19deacfd_6d39fd4d",
        "filename": "av1/decoder/obu.c",
        "patchSetId": 1
      },
      "lineNbr": 138,
      "author": {
        "id": 9545
      },
      "writtenOn": "2018-05-21T21:08:33Z",
      "side": 1,
      "message": "Optional: My preference would be to delete this check. I leave the decision to you.",
      "range": {
        "startLine": 137,
        "startChar": 0,
        "endLine": 138,
        "endChar": 61
      },
      "revId": "15b279ec74bcb02465e1ed60805e73facc08b493",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "325f283d_3f1dd2d9",
        "filename": "av1/decoder/obu.c",
        "patchSetId": 1
      },
      "lineNbr": 183,
      "author": {
        "id": 9545
      },
      "writtenOn": "2018-05-21T21:08:33Z",
      "side": 1,
      "message": "Your change below made me realize this is wrong. This should be changed to set cm-\u003eerror.error_code and return 0.\n\nDo you want to make fix these \"return AOM_CODEC_UNSUP_BITSTREAM\" lines as part of this CL? Or I can write a separate CL to do that.",
      "range": {
        "startLine": 183,
        "startChar": 4,
        "endLine": 183,
        "endChar": 37
      },
      "revId": "15b279ec74bcb02465e1ed60805e73facc08b493",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2d96385a_38532835",
        "filename": "av1/decoder/obu.c",
        "patchSetId": 1
      },
      "lineNbr": 225,
      "author": {
        "id": 9545
      },
      "writtenOn": "2018-05-21T21:08:33Z",
      "side": 1,
      "message": "Same here: this error code is not accurate. This is an internal error (a bug in our own code), not a corrupt frame.",
      "range": {
        "startLine": 225,
        "startChar": 27,
        "endLine": 225,
        "endChar": 50
      },
      "revId": "15b279ec74bcb02465e1ed60805e73facc08b493",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "570c36fa_8010a195",
        "filename": "av1/decoder/obu.c",
        "patchSetId": 1
      },
      "lineNbr": 555,
      "author": {
        "id": 9545
      },
      "writtenOn": "2018-05-21T21:08:33Z",
      "side": 1,
      "message": "The !cm-\u003eerror.error_code check here can also detect failure of the read_sequence_header_obu() call. (Please see my comment below.) I have seen us exit the while loop here on error when I investigated ASAN warnings.",
      "range": {
        "startLine": 555,
        "startChar": 2,
        "endLine": 555,
        "endChar": 61
      },
      "revId": "15b279ec74bcb02465e1ed60805e73facc08b493",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4681ab06_491dc1b5",
        "filename": "av1/decoder/obu.c",
        "patchSetId": 1
      },
      "lineNbr": 604,
      "author": {
        "id": 9545
      },
      "writtenOn": "2018-05-21T21:08:33Z",
      "side": 1,
      "message": "We may be able to rely on the check at line 555. But it\u0027s fine to check here, because it\u0027s easier to verify it\u0027s correct.",
      "range": {
        "startLine": 604,
        "startChar": 10,
        "endLine": 604,
        "endChar": 59
      },
      "revId": "15b279ec74bcb02465e1ed60805e73facc08b493",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0",
      "unresolved": true
    }
  ]
}