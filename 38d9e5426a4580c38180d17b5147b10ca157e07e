{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "efd29e66_4d579d11",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 33002
      },
      "writtenOn": "2023-12-06T16:16:02Z",
      "side": 1,
      "message": "In the parent commit, if an allocation fails when `ctrl_set_color_range()` is invoked, (`initialize_encoder() -\u003eAOM_CODEC_CONTROL_TYPECHECKED()` in line 1558), it will result in SEGV error since there is no `ctx_exit_on_error()` call to stop further processing. This CL fixes this issue by adding `ctx_exit_on_error()` after the `AOM_CODEC_CONTROL_TYPECHECKED()` call so that the application exits gracefully if an error is encountered without further processing. Also added the missing `ctx_exit_on_error()` call for other instances of `AOM_CODEC_CONTROL_TYPECHECKED()` in `aomenc.c` to ensure that an error is correctly serviced.\n\nThis change is bit-exact and has been verified using bitstream-match tests for a combination of various configuration values for --threads, --tile-rows, --tile-columns, --cpu-used, --end-usage, --row-mt, --fp-mt, etc. Validated all unit-tests with sanitizers (address and thread) and valgrind.",
      "revId": "38d9e5426a4580c38180d17b5147b10ca157e07e",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4305219e_c29dd4db",
        "filename": "apps/aomenc.c",
        "patchSetId": 3
      },
      "lineNbr": 1536,
      "author": {
        "id": 5020
      },
      "writtenOn": "2023-12-06T19:34:24Z",
      "side": 1,
      "message": "Are these hiding any known failures if execution continues?",
      "revId": "38d9e5426a4580c38180d17b5147b10ca157e07e",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bf5b33ff_287c020a",
        "filename": "apps/aomenc.c",
        "patchSetId": 3
      },
      "lineNbr": 1536,
      "author": {
        "id": 33002
      },
      "writtenOn": "2023-12-07T14:28:09Z",
      "side": 1,
      "message": "We have seen SEGV error when there is an allocation failure in `AOM_CODEC_CONTROL_TYPECHECKED()` call at line number 1563. To respect the error code returned by the `AOM_CODEC_CONTROL_TYPECHECKED()` call, we have added the `ctx_exit_on_error()` call at all instances.",
      "parentUuid": "4305219e_c29dd4db",
      "revId": "38d9e5426a4580c38180d17b5147b10ca157e07e",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a4a5905c_6d37e447",
        "filename": "apps/aomenc.c",
        "patchSetId": 3
      },
      "lineNbr": 1536,
      "author": {
        "id": 9545
      },
      "writtenOn": "2023-12-07T14:40:51Z",
      "side": 1,
      "message": "Satheesh: Thank you for the reply. I am not familiar with `ctx_exit_on_error()`. I inspected all the `ctx_exit_on_error()` calls and found that it has been used after `aom_codec_control()` calls. So this CL looks good.\n\nI found two issues with the existing `ctx_exit_on_error()` calls.\n\n1. In two places there seems to be a duplicate error check and error message. Here is an example:\n\n```\n    if (aom_codec_control(\u0026stream-\u003eencoder, ctrl, value))\n      fprintf(stderr, \"Error: Tried to set control %d \u003d %d\\n\", ctrl, value);\n\n    ctx_exit_on_error(\u0026stream-\u003eencoder, \"Failed to control codec\");\n```\n\n2. In the following code, I think we use the aom_codec_control() outputs before error checking:\n\n```\n  /* Get the internal reference frame */\n  AOM_CODEC_CONTROL_TYPECHECKED(\u0026stream-\u003eencoder, AV1_GET_NEW_FRAME_IMAGE,\n                                \u0026enc_img);\n  AOM_CODEC_CONTROL_TYPECHECKED(\u0026stream-\u003edecoder, AV1_GET_NEW_FRAME_IMAGE,\n                                \u0026dec_img);\n\n  if ((enc_img.fmt \u0026 AOM_IMG_FMT_HIGHBITDEPTH) !\u003d\n      (dec_img.fmt \u0026 AOM_IMG_FMT_HIGHBITDEPTH)) {\n    if (enc_img.fmt \u0026 AOM_IMG_FMT_HIGHBITDEPTH) {\n      aom_image_t enc_hbd_img;\n      aom_img_alloc(\u0026enc_hbd_img, enc_img.fmt - AOM_IMG_FMT_HIGHBITDEPTH,\n                    enc_img.d_w, enc_img.d_h, 16);\n      aom_img_truncate_16_to_8(\u0026enc_hbd_img, \u0026enc_img);\n      enc_img \u003d enc_hbd_img;\n    }\n    if (dec_img.fmt \u0026 AOM_IMG_FMT_HIGHBITDEPTH) {\n      aom_image_t dec_hbd_img;\n      aom_img_alloc(\u0026dec_hbd_img, dec_img.fmt - AOM_IMG_FMT_HIGHBITDEPTH,\n                    dec_img.d_w, dec_img.d_h, 16);\n      aom_img_truncate_16_to_8(\u0026dec_hbd_img, \u0026dec_img);\n      dec_img \u003d dec_hbd_img;\n    }\n  }\n\n  ctx_exit_on_error(\u0026stream-\u003eencoder, \"Failed to get encoder reference frame\");\n  ctx_exit_on_error(\u0026stream-\u003edecoder, \"Failed to get decoder reference frame\");\n```",
      "parentUuid": "bf5b33ff_287c020a",
      "revId": "38d9e5426a4580c38180d17b5147b10ca157e07e",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f5dbf5ba_f8a6d7c6",
        "filename": "apps/aomenc.c",
        "patchSetId": 3
      },
      "lineNbr": 1536,
      "author": {
        "id": 5020
      },
      "writtenOn": "2023-12-07T23:56:43Z",
      "side": 1,
      "message": "\u003e We have seen SEGV error when there is an allocation failure in AOM_CODEC_CONTROL_TYPECHECKED() call at line number 1563. \n\nWhat is the segfault exactly? A user application may call multiple controls and not check the result. If we can make the api more robust we should.",
      "parentUuid": "a4a5905c_6d37e447",
      "revId": "38d9e5426a4580c38180d17b5147b10ca157e07e",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "93857c4c_5c9878d2",
        "filename": "apps/aomenc.c",
        "patchSetId": 3
      },
      "lineNbr": 1536,
      "author": {
        "id": 33002
      },
      "writtenOn": "2023-12-08T15:01:30Z",
      "side": 1,
      "message": "When `alloc_compressor_data()` is invoked through the control call at line number 1563 (`AOM_CODEC_CONTROL_TYPECHECKED()` -\u003e `ctrl_set_color_range()` -\u003e  `av1_change_config()` -\u003e `alloc_compressor_data()`) and an allocation fails, due to longjmp subsequent allocations are skipped. In the absence of `ctx_exit_on_error()` call, the execution continues and later during the encode stage these unallocated buffers are accessed resulting in a segmentation fault.",
      "parentUuid": "f5dbf5ba_f8a6d7c6",
      "revId": "38d9e5426a4580c38180d17b5147b10ca157e07e",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fcb2c88f_103a03a9",
        "filename": "apps/aomenc.c",
        "patchSetId": 3
      },
      "lineNbr": 1536,
      "author": {
        "id": 5020
      },
      "writtenOn": "2023-12-08T20:25:10Z",
      "side": 1,
      "message": "\u003e When `alloc_compressor_data()` is invoked through the control call at line number 1563 (`AOM_CODEC_CONTROL_TYPECHECKED()` -\u003e `ctrl_set_color_range()` -\u003e  `av1_change_config()` -\u003e `alloc_compressor_data()`) and an allocation fails, due to longjmp subsequent allocations are skipped. In the absence of `ctx_exit_on_error()` call, the execution continues and later during the encode stage these unallocated buffers are accessed resulting in a segmentation fault.\n\nIt sounds like the buffers should be zeroed or we\u0027re missing some error checks.",
      "parentUuid": "93857c4c_5c9878d2",
      "revId": "38d9e5426a4580c38180d17b5147b10ca157e07e",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4b3cb02f_fe463069",
        "filename": "apps/aomenc.c",
        "patchSetId": 3
      },
      "lineNbr": 1536,
      "author": {
        "id": 9545
      },
      "writtenOn": "2023-12-09T18:16:44Z",
      "side": 1,
      "message": "Satheesh: It\u0027s not clear why setting the color range will cause `alloc_compressor_data()` to be called in `av1_change_config()`, because the color range should be unrelated to width, height, and sb_size:\n\n```\n  if (cm-\u003ewidth \u003e initial_dimensions-\u003ewidth ||\n      cm-\u003eheight \u003e initial_dimensions-\u003eheight || is_sb_size_changed) {\n    av1_free_context_buffers(cm);\n    av1_free_shared_coeff_buffer(\u0026cpi-\u003etd.shared_coeff_buf);\n    av1_free_sms_tree(\u0026cpi-\u003etd);\n    av1_free_pmc(cpi-\u003etd.firstpass_ctx, av1_num_planes(cm));\n    cpi-\u003etd.firstpass_ctx \u003d NULL;\n    alloc_compressor_data(cpi);\n    realloc_segmentation_maps(cpi);\n    initial_dimensions-\u003ewidth \u003d initial_dimensions-\u003eheight \u003d 0;\n  }\n```\n\nIf it\u0027s too much work, could you reproduce the error and find out why this conditional expression is true when we set the color range?\n\nJames: The code snippet above is a typical example of how libaom reallocate buffers. It first frees the old buffers and then allocates the new buffers. This has the downside that if memory allocation fails, we have no buffers and the object is left in a bad state.\n\nTherefore, I am afraid that we will need to treat `AOM_CODEC_MEM_ERROR` as an unrecoverable error. It is not safe to call any `aom_codec_` function other than `aom_codec_destroy()`.\n\nIn fact, I think any error raised by `aom_internal_error()` is running the risk of leaving the object in a bad state. If we want to defend against this, a good solution is to add an \"error state\" boolean flag to the codec object. A public codec function will first check if the codec object is in the error state.",
      "parentUuid": "fcb2c88f_103a03a9",
      "revId": "38d9e5426a4580c38180d17b5147b10ca157e07e",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f3049faa_e40b61ea",
        "filename": "apps/aomenc.c",
        "patchSetId": 3
      },
      "lineNbr": 1536,
      "author": {
        "id": 5020
      },
      "writtenOn": "2023-12-11T21:29:03Z",
      "side": 1,
      "message": "\u003e Satheesh: It\u0027s not clear why setting the color range will cause `alloc_compressor_data()` to be called in `av1_change_config()`, because the color range should be unrelated to width, height, and sb_size:\n\u003e \n\u003e ```\n\u003e   if (cm-\u003ewidth \u003e initial_dimensions-\u003ewidth ||\n\u003e       cm-\u003eheight \u003e initial_dimensions-\u003eheight || is_sb_size_changed) {\n\u003e     av1_free_context_buffers(cm);\n\u003e     av1_free_shared_coeff_buffer(\u0026cpi-\u003etd.shared_coeff_buf);\n\u003e     av1_free_sms_tree(\u0026cpi-\u003etd);\n\u003e     av1_free_pmc(cpi-\u003etd.firstpass_ctx, av1_num_planes(cm));\n\u003e     cpi-\u003etd.firstpass_ctx \u003d NULL;\n\u003e     alloc_compressor_data(cpi);\n\u003e     realloc_segmentation_maps(cpi);\n\u003e     initial_dimensions-\u003ewidth \u003d initial_dimensions-\u003eheight \u003d 0;\n\u003e   }\n\u003e ```\n\u003e \n\u003e If it\u0027s too much work, could you reproduce the error and find out why this conditional expression is true when we set the color range?\n\u003e \n\u003e James: The code snippet above is a typical example of how libaom reallocate buffers. It first frees the old buffers and then allocates the new buffers. This has the downside that if memory allocation fails, we have no buffers and the object is left in a bad state.\n\u003e \n\u003e Therefore, I am afraid that we will need to treat `AOM_CODEC_MEM_ERROR` as an unrecoverable error. It is not safe to call any `aom_codec_` function other than `aom_codec_destroy()`.\n\u003e \n\u003e In fact, I think any error raised by `aom_internal_error()` is running the risk of leaving the object in a bad state. If we want to defend against this, a good solution is to add an \"error state\" boolean flag to the codec object. A public codec function will first check if the codec object is in the error state.\n\nYes, I think that would be a good option. Note the decoder has been positioned to be able to recover from earlier errors though.",
      "parentUuid": "4b3cb02f_fe463069",
      "revId": "38d9e5426a4580c38180d17b5147b10ca157e07e",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e4dd2679_27f04e31",
        "filename": "apps/aomenc.c",
        "patchSetId": 3
      },
      "lineNbr": 1536,
      "author": {
        "id": 33002
      },
      "writtenOn": "2023-12-12T14:18:18Z",
      "side": 1,
      "message": "\u003e Satheesh: It\u0027s not clear why setting the color range will cause `alloc_compressor_data()` to be called in `av1_change_config()`, because the color range should be unrelated to width, height, and sb_size:\n```  \n\u003e if (cm-\u003ewidth \u003e initial_dimensions-\u003ewidth ||\n      cm-\u003eheight \u003e initial_dimensions-\u003eheight || is_sb_size_changed) {\n    av1_free_context_buffers(cm);\n    av1_free_shared_coeff_buffer(\u0026cpi-\u003etd.shared_coeff_buf);\n    av1_free_sms_tree(\u0026cpi-\u003etd);\n    av1_free_pmc(cpi-\u003etd.firstpass_ctx, av1_num_planes(cm));\n    cpi-\u003etd.firstpass_ctx \u003d NULL;\n    alloc_compressor_data(cpi);\n    realloc_segmentation_maps(cpi);\n    initial_dimensions-\u003ewidth \u003d initial_dimensions-\u003eheight \u003d 0;\n  }\n```\n\u003e If it\u0027s too much work, could you reproduce the error and find out why this conditional expression is true when we set the color range?\n   \nHi Wan-Teh,\nWe see that `cpi-\u003einitial_dimensions.width` and ` cpi-\u003einitial_dimensions.height` are initialized to zero during `av1_create_compressor()` and not updated until `av1_check_initial_width()` is invoked during the process calls (encoder_encode()). Because of this, the condition `\nif (cm-\u003ewidth \u003e initial_dimensions-\u003ewidth || \ncm-\u003eheight \u003e initial_dimensions-\u003eheight)` will always be true for all the control calls before the first encoder_encode() call and hence `alloc_compressor_data()` is invoked even if color range is being set (in this case).\n\nWe feel that these repeated calls to `alloc_compressor_data()` are not intended and seem to have come due to the changes done in the CL \nhttps://aomedia-review.googlesource.com/c/aom/+/182413.",
      "parentUuid": "f3049faa_e40b61ea",
      "revId": "38d9e5426a4580c38180d17b5147b10ca157e07e",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "501add97_2d30442c",
        "filename": "apps/aomenc.c",
        "patchSetId": 3
      },
      "lineNbr": 1565,
      "author": {
        "id": 9545
      },
      "writtenOn": "2023-12-06T23:12:20Z",
      "side": 1,
      "message": "Nit: remove \"codec\" from the error message?",
      "revId": "38d9e5426a4580c38180d17b5147b10ca157e07e",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d1da9ad0_b9ffcfe2",
        "filename": "apps/aomenc.c",
        "patchSetId": 3
      },
      "lineNbr": 1565,
      "author": {
        "id": 33002
      },
      "writtenOn": "2023-12-07T14:28:09Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "501add97_2d30442c",
      "revId": "38d9e5426a4580c38180d17b5147b10ca157e07e",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    }
  ]
}