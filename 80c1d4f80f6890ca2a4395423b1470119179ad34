{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "1547b29d_e9ed986e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 33002
      },
      "writtenOn": "2023-12-13T13:23:30Z",
      "side": 1,
      "message": "In the parent commit, if the allocation in `av1_int_pro_motion_estimation()` (`av1_choose_var_based_partitioning()-\u003esetup_planes()-\u003eav1_int_pro_motion_estimation()`) fails, the local buffer `vt` in `av1_choose_var_based_partitioning()` will show up as leak. This CL fixes this issue by moving the allocation of the `vt` buffer (to line number 1722) after the call to `setup_planes()`.\n\nThis CL also uses thread-specific `xd-\u003eerror_info` instead of `cm-\u003eerror` for error handling in `av1_int_pro_motion_estimation()`, as it can be called from a multi-threaded path.\n\nThis change is bit-exact and has been verified using bitstream-match tests for a combination of various configuration values for --threads, --tile-rows, --tile-columns, --cpu-used, --end-usage, --row-mt, --fp-mt, etc. Validated all unit-tests with sanitizers (address and thread) and valgrind.",
      "revId": "80c1d4f80f6890ca2a4395423b1470119179ad34",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e7ccb4c9_d6b12f67",
        "filename": "av1/encoder/var_based_part.c",
        "patchSetId": 1
      },
      "lineNbr": 1721,
      "author": {
        "id": 9545
      },
      "writtenOn": "2023-12-14T01:15:20Z",
      "side": 1,
      "message": "Move the declaration of `vt` here:\n\n```\n  VP128x128 *vt;\n```",
      "revId": "80c1d4f80f6890ca2a4395423b1470119179ad34",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "cd5cfb19_d8aeaf64",
        "filename": "av1/encoder/var_based_part.c",
        "patchSetId": 1
      },
      "lineNbr": 1721,
      "author": {
        "id": 33002
      },
      "writtenOn": "2023-12-14T14:51:15Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "e7ccb4c9_d6b12f67",
      "revId": "80c1d4f80f6890ca2a4395423b1470119179ad34",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "52b2a64d_cbe09ede",
        "filename": "av1/encoder/var_based_part.c",
        "patchSetId": 1
      },
      "lineNbr": 1721,
      "author": {
        "id": 9545
      },
      "writtenOn": "2023-12-14T22:56:58Z",
      "side": 1,
      "message": "I noticed that the `vt2` variable is apparently related to `vt`. So I think their declarations should stay together.",
      "parentUuid": "cd5cfb19_d8aeaf64",
      "revId": "80c1d4f80f6890ca2a4395423b1470119179ad34",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ea4d19ed_e904df6a",
        "filename": "av1/encoder/var_based_part.c",
        "patchSetId": 1
      },
      "lineNbr": 1769,
      "author": {
        "id": 9545
      },
      "writtenOn": "2023-12-14T01:15:20Z",
      "side": 1,
      "message": "(This question is unrelated to this CL.) I don\u0027t see how we ensure `vt2` is not null here.",
      "revId": "80c1d4f80f6890ca2a4395423b1470119179ad34",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d31d0115_6efce074",
        "filename": "av1/encoder/var_based_part.c",
        "patchSetId": 1
      },
      "lineNbr": 1769,
      "author": {
        "id": 33002
      },
      "writtenOn": "2023-12-15T13:14:40Z",
      "side": 1,
      "message": "As per the current code, `threshold_4x4avg` is always set to `INT64_MAX`  and hence the `vt2` buffer is never allocated (please check line 1743). \n`vt2` is only used if `!is_key_frame`  and `variance4x4downsample[]` is set to 1 (please see lines 1766 - 1770 and 1900-1904). But the function `fill_variance_tree_leaves()` sets `variance4x4downsample[]` to 0 for non-key frames because of which `vt2` is never used.\n\nSince the conditions for allocation and consumption of the buffer is not the same, any possible code change in future overlooking this above fact can lead to accessing an unallocated `vt2`. We feel that adding an assert as per the below code snippet would bring this to notice if the code is modified without taking care of this constraint.\n\n```\nVP16x16 *vtemp;\nif (!is_key_frame) {\n  assert(vt2 !\u003d NULL);\n  vtemp \u003d \u0026vt2[lvl1_scale_idx + lvl2_idx];\nelse {\n  vtemp \u003d \u0026vt-\u003esplit[blk64_idx].split[lvl1_idx].split[lvl2_idx];\n}\n```\nPlease let us know your opinion.",
      "parentUuid": "ea4d19ed_e904df6a",
      "revId": "80c1d4f80f6890ca2a4395423b1470119179ad34",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    }
  ]
}