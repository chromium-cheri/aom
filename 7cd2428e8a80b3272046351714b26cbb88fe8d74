{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "8af44bb0_636b18d7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5020
      },
      "writtenOn": "2023-03-25T05:18:32Z",
      "side": 1,
      "message": "Looking a little closer, this is VP8 only [1]. I\u0027ll delete this one first and then double check the libvpx implementations to make sure they\u0027re consistent with the call site, not just the unit test.\n\n[1] https://chromium.googlesource.com/webm/libvpx/+/refs/tags/v1.13.0/vp8/encoder/pickinter.c#171",
      "revId": "7cd2428e8a80b3272046351714b26cbb88fe8d74",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "09bfe1f3_c91f81d6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5020
      },
      "writtenOn": "2023-03-25T05:18:51Z",
      "side": 1,
      "message": "\u003e Looking a little closer, this is VP8 only [1]. I\u0027ll delete this one first and then double check the libvpx implementations to make sure they\u0027re consistent with the call site, not just the unit test.\n\u003e \n\u003e [1] https://chromium.googlesource.com/webm/libvpx/+/refs/tags/v1.13.0/vp8/encoder/pickinter.c#171\n\n-\u003e https://aomedia-review.googlesource.com/c/aom/+/172644",
      "parentUuid": "8af44bb0_636b18d7",
      "revId": "7cd2428e8a80b3272046351714b26cbb88fe8d74",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5747c660_074afc3f",
        "filename": "aom_dsp/arm/mem_neon.h",
        "patchSetId": 2
      },
      "lineNbr": 94,
      "author": {
        "id": 9545
      },
      "writtenOn": "2023-03-08T22:59:39Z",
      "side": 1,
      "message": "Jonathan: The second version of aom_get4x4sse_cs_neon() calls this function to load src and ref, and the comment here says alignment is guaranteed. This is why I asked if the first version of aom_get4x4sse_cs_neon() can also assume alignment of the src and ref buffer addresses.",
      "revId": "7cd2428e8a80b3272046351714b26cbb88fe8d74",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1588fbd5_a1fbbac2",
        "filename": "aom_dsp/arm/mem_neon.h",
        "patchSetId": 2
      },
      "lineNbr": 94,
      "author": {
        "id": 31042
      },
      "writtenOn": "2023-03-08T23:09:45Z",
      "side": 1,
      "message": "Ah, I understand the reason for the question now - though my answer is still the same. I guess when this is clarified we should modify the appropriate version.",
      "parentUuid": "5747c660_074afc3f",
      "revId": "7cd2428e8a80b3272046351714b26cbb88fe8d74",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a248bab2_0622153f",
        "filename": "aom_dsp/arm/variance_neon.c",
        "patchSetId": 2
      },
      "lineNbr": 482,
      "author": {
        "id": 9545
      },
      "writtenOn": "2023-03-08T22:10:21Z",
      "side": 1,
      "message": "Jonathan: Can this function also rely on the alignment guarantee and use `vld1q_lane_u32`?",
      "revId": "7cd2428e8a80b3272046351714b26cbb88fe8d74",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c34eab12_0bf00c6d",
        "filename": "aom_dsp/arm/variance_neon.c",
        "patchSetId": 2
      },
      "lineNbr": 482,
      "author": {
        "id": 31042
      },
      "writtenOn": "2023-03-08T22:36:59Z",
      "side": 1,
      "message": "I am unsure about the alignment of the src and ref buffer addresses - maybe James Zern can clarify. Regardless, for AArch64 targets at least, the generated code will be the same as if we had used vld1q_lane_u32 - since there are no issues with unaligned memory accesses on AArch64.",
      "parentUuid": "a248bab2_0622153f",
      "revId": "7cd2428e8a80b3272046351714b26cbb88fe8d74",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "28fdac01_1b89a611",
        "filename": "aom_dsp/arm/variance_neon.c",
        "patchSetId": 2
      },
      "lineNbr": 482,
      "author": {
        "id": 5020
      },
      "writtenOn": "2023-03-25T02:12:12Z",
      "side": 1,
      "message": "\u003e I am unsure about the alignment of the src and ref buffer addresses - maybe James Zern can clarify. Regardless, for AArch64 targets at least, the generated code will be the same as if we had used vld1q_lane_u32 - since there are no issues with unaligned memory accesses on AArch64.\n\nGiven src/ref are produced from block offsets this should be fine. Even if the allocations aren\u0027t explicitly aligned, the default malloc alignment will suffice.\n\nI knew AArch64 supported unaligned accesses, does that carry over to AArch32?",
      "parentUuid": "c34eab12_0bf00c6d",
      "revId": "7cd2428e8a80b3272046351714b26cbb88fe8d74",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    }
  ]
}