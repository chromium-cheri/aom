{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "35d0bb90_ae9ee7d9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 33002
      },
      "writtenOn": "2023-12-15T13:08:45Z",
      "side": 1,
      "message": "Currently if any allocation fails in `av1_alloc_txb_buf()`, the unallocated buffers can hold the stale address from previous allocations which will result in double free error in `av1_free_txb_buf()` during `encoder_destroy()`. This CL fixes this issue by clearing the dangling pointers immediately after freeing in `av1_free_txb_buf()`.\n\nThis change is bit-exact and has been verified using bitstream-match tests for a combination of various configuration values for --threads, --tile-rows, --tile-columns, --cpu-used, --end-usage, --row-mt, --fp-mt, etc. Validated all unit-tests with sanitizers (address and thread) and valgrind.",
      "revId": "7458e4e54a24e1e4d04fdfaba3824b22f3043e89",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "430610e2_f6d3cd60",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 9545
      },
      "writtenOn": "2023-12-15T16:49:02Z",
      "side": 1,
      "message": "LGTM.",
      "revId": "7458e4e54a24e1e4d04fdfaba3824b22f3043e89",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d5306533_7fd189ba",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 9545
      },
      "writtenOn": "2023-12-15T16:49:02Z",
      "side": 1,
      "message": "In general it is good to always set a pointer to null after freeing it. (If there is an associated buffer size field, it should be set to 0.) The only exception is when we are immediately freeing the struct that contains the pointer. Here is an example:\n\n\n```\nvoid aom_img_metadata_free(aom_metadata_t *metadata) {\n  if (metadata) {\n    if (metadata-\u003epayload) free(metadata-\u003epayload);\n    free(metadata);\n  }\n}\n\n...\n\nvoid aom_img_metadata_array_free(aom_metadata_array_t *arr) {\n  if (arr) {\n    if (arr-\u003emetadata_array) {\n      for (size_t i \u003d 0; i \u003c arr-\u003esz; i++) {\n        aom_img_metadata_free(arr-\u003emetadata_array[i]);\n      }\n      free(arr-\u003emetadata_array);\n    }\n    free(arr);\n  }\n}\n```\n\nEven in that case, some people still set the pointer to null so that if there is a use-after-free bug, the dangling pointer won\u0027t be used and we can detect the bug when the null pointer is defererenced.",
      "parentUuid": "35d0bb90_ae9ee7d9",
      "revId": "7458e4e54a24e1e4d04fdfaba3824b22f3043e89",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    }
  ]
}